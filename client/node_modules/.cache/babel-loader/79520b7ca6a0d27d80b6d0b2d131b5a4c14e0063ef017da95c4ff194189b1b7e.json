{"ast":null,"code":"import axios from 'axios';\n\n// In development, use relative URL to go through proxy (avoids CORS)\n// In production, use full URL from environment variable\nconst API_BASE_URL = process.env.REACT_APP_API_URL || (process.env.NODE_ENV === 'production' ? '/api' : '/api');\n\n// Backend health check with retry logic\nlet backendHealthCheckPromise = null;\nlet lastHealthCheck = null;\nconst HEALTH_CHECK_CACHE_MS = 5000; // Cache health check for 5 seconds\n\nconst checkBackendHealthWithCache = async () => {\n  const now = Date.now();\n\n  // Return cached result if available and recent\n  if (lastHealthCheck && now - lastHealthCheck.timestamp < HEALTH_CHECK_CACHE_MS) {\n    return lastHealthCheck.isHealthy;\n  }\n\n  // If a health check is already in progress, wait for it\n  if (backendHealthCheckPromise) {\n    return backendHealthCheckPromise;\n  }\n\n  // Start new health check\n  backendHealthCheckPromise = (async () => {\n    try {\n      // Health check endpoint - use relative path to go through proxy\n      const healthUrl = process.env.NODE_ENV === 'production' ? '/api/health' : '/api/health';\n      const response = await axios.get(healthUrl, {\n        timeout: 3000,\n        validateStatus: status => status === 200\n      });\n      lastHealthCheck = {\n        isHealthy: true,\n        timestamp: now\n      };\n      return true;\n    } catch (error) {\n      lastHealthCheck = {\n        isHealthy: false,\n        timestamp: now\n      };\n      return false;\n    } finally {\n      backendHealthCheckPromise = null;\n    }\n  })();\n  return backendHealthCheckPromise;\n};\n\n// CSRF token management\nlet csrfToken = null;\nlet csrfTokenPromise = null;\nconst getCsrfToken = async () => {\n  // Return cached token if available\n  if (csrfToken) {\n    return csrfToken;\n  }\n\n  // If a token fetch is already in progress, wait for it\n  if (csrfTokenPromise) {\n    return csrfTokenPromise;\n  }\n\n  // Fetch new CSRF token\n  csrfTokenPromise = (async () => {\n    try {\n      const response = await axios.get('/csrf-token', {\n        baseURL: API_BASE_URL,\n        timeout: 5000\n      });\n      csrfToken = response.data.csrfToken;\n      return csrfToken;\n    } catch (error) {\n      console.warn('Failed to fetch CSRF token:', error);\n      // Return null if token fetch fails (will retry on next request)\n      return null;\n    } finally {\n      csrfTokenPromise = null;\n    }\n  })();\n  return csrfTokenPromise;\n};\n\n// Create axios instance with default config\nconst apiClient = axios.create({\n  baseURL: API_BASE_URL,\n  headers: {\n    'Content-Type': 'application/json'\n  },\n  // Remove withCredentials to avoid CORS issues - server CORS is configured correctly\n  // withCredentials: true,\n  timeout: 120000 // 120 second timeout (increased for Salesforce API calls, especially KPIs)\n});\n\n// Request interceptor to add auth token and CSRF token\napiClient.interceptors.request.use(async config => {\n  var _config$url, _config$method;\n  const token = localStorage.getItem('token');\n  if (token) {\n    config.headers.Authorization = `Bearer ${token}`;\n  }\n\n  // Add CSRF token for state-changing requests (POST, PUT, DELETE, PATCH)\n  // Skip CSRF for auth endpoints and GET requests\n  if (!((_config$url = config.url) !== null && _config$url !== void 0 && _config$url.includes('/auth/')) && ['POST', 'PUT', 'DELETE', 'PATCH'].includes((_config$method = config.method) === null || _config$method === void 0 ? void 0 : _config$method.toUpperCase())) {\n    try {\n      const csrf = await getCsrfToken();\n      if (csrf) {\n        config.headers['X-CSRF-Token'] = csrf;\n      }\n    } catch (error) {\n      console.warn('Failed to get CSRF token for request:', error);\n    }\n  }\n\n  // Always log request details in development for debugging\n  if (process.env.NODE_ENV === 'development') {\n    console.log('API Request:', {\n      url: config.url,\n      method: config.method,\n      baseURL: config.baseURL,\n      fullURL: `${config.baseURL}${config.url}`,\n      hasToken: !!token,\n      hasCsrfToken: !!config.headers['X-CSRF-Token'],\n      tokenLength: token ? token.length : 0,\n      headers: {\n        'Content-Type': config.headers['Content-Type'],\n        'Authorization': config.headers.Authorization ? 'Bearer ***' : 'None',\n        'X-CSRF-Token': config.headers['X-CSRF-Token'] ? '***' : 'None',\n        'Origin': window.location.origin\n      },\n      withCredentials: config.withCredentials\n    });\n  } else if (!token) {\n    console.warn('API Request without token:', {\n      url: config.url,\n      method: config.method\n    });\n  }\n  return config;\n}, error => {\n  console.error('Request interceptor error:', error);\n  return Promise.reject(error);\n});\n\n// Use the cached health check function\nconst checkBackendHealth = checkBackendHealthWithCache;\n\n// Export health check function for use in other modules\nexport { checkBackendHealth };\n\n// Response interceptor for error handling\napiClient.interceptors.response.use(response => response, async error => {\n  var _error$response, _error$response3, _error$response4, _error$response5, _error$response5$data, _error$response5$data2, _error$response6;\n  // Handle 504 Gateway Timeout errors\n  if (((_error$response = error.response) === null || _error$response === void 0 ? void 0 : _error$response.status) === 504 || error.code === 'ECONNREFUSED' || error.code === 'ETIMEDOUT') {\n    var _error$config, _error$response2;\n    const url = ((_error$config = error.config) === null || _error$config === void 0 ? void 0 : _error$config.url) || '';\n    console.error('Backend connection error:', {\n      status: (_error$response2 = error.response) === null || _error$response2 === void 0 ? void 0 : _error$response2.status,\n      code: error.code,\n      message: error.message,\n      url: url\n    });\n    error.message = 'Backend server is not responding. Please ensure the server is running on port 5000.';\n    error.isBackendDown = true;\n    error.userMessage = 'Unable to connect to server. Please ensure the backend server is running on port 5000.';\n  }\n\n  // Handle 404 errors - check if backend is ready\n  if (((_error$response3 = error.response) === null || _error$response3 === void 0 ? void 0 : _error$response3.status) === 404) {\n    var _error$config2;\n    const url = ((_error$config2 = error.config) === null || _error$config2 === void 0 ? void 0 : _error$config2.url) || '';\n    const isAuthEndpoint = url.includes('/auth/');\n\n    // For auth endpoints, check if backend is ready\n    if (isAuthEndpoint) {\n      const isHealthy = await checkBackendHealth();\n      if (!isHealthy) {\n        console.error('Backend is not responding. Please ensure the server is running on port 5000.');\n        error.message = 'Backend server is not responding. Please ensure the server is running on port 5000.';\n        error.isBackendDown = true;\n      } else {\n        console.error('404 on auth endpoint - route may not be registered:', url);\n        error.message = `Route not found: ${url}. Please check that the backend server has restarted and routes are registered.`;\n      }\n    }\n  }\n\n  // Handle network errors (server not running, CORS blocked, etc.)\n  if (!error.response) {\n    var _error$config3, _error$config4;\n    const url = ((_error$config3 = error.config) === null || _error$config3 === void 0 ? void 0 : _error$config3.url) || '';\n    const baseURL = ((_error$config4 = error.config) === null || _error$config4 === void 0 ? void 0 : _error$config4.baseURL) || API_BASE_URL;\n    const fullURL = `${baseURL}${url}`;\n    console.error('Network error - request did not reach server:', {\n      url: url,\n      fullURL: fullURL,\n      baseURL: baseURL,\n      message: error.message,\n      code: error.code,\n      name: error.name\n    });\n\n    // Check if it's a CORS error\n    if (error.message && (error.message.includes('CORS') || error.message.includes('Network Error') || error.code === 'ERR_NETWORK' || error.code === 'ERR_BLOCKED_BY_CLIENT')) {\n      console.error('CORS or network blocking detected. Check:');\n      console.error('1. Server is running on port 5000');\n      console.error('2. CORS is configured correctly on server');\n      console.error('3. Browser is not blocking the request');\n      console.error('4. Request URL:', fullURL);\n    }\n    const isAuthEndpoint = url.includes('/auth/');\n\n    // For login/verify endpoints, provide helpful error message\n    if (isAuthEndpoint && (url.includes('/login') || url.includes('/verify'))) {\n      // Don't show error toast for network errors on login - let the component handle it\n      // The error will be caught in the login function and shown there\n    }\n    return Promise.reject(error);\n  }\n\n  // Handle CSRF token errors - refresh token and retry\n  if (((_error$response4 = error.response) === null || _error$response4 === void 0 ? void 0 : _error$response4.status) === 403 && (_error$response5 = error.response) !== null && _error$response5 !== void 0 && (_error$response5$data = _error$response5.data) !== null && _error$response5$data !== void 0 && (_error$response5$data2 = _error$response5$data.error) !== null && _error$response5$data2 !== void 0 && _error$response5$data2.includes('CSRF')) {\n    // Clear cached CSRF token and retry once\n    csrfToken = null;\n    const originalRequest = error.config;\n\n    // Only retry if we haven't already retried\n    if (!originalRequest._retry) {\n      originalRequest._retry = true;\n      try {\n        const newCsrfToken = await getCsrfToken();\n        if (newCsrfToken && originalRequest.headers) {\n          originalRequest.headers['X-CSRF-Token'] = newCsrfToken;\n          return apiClient(originalRequest);\n        }\n      } catch (csrfError) {\n        console.error('Failed to refresh CSRF token:', csrfError);\n      }\n    }\n  }\n  if (((_error$response6 = error.response) === null || _error$response6 === void 0 ? void 0 : _error$response6.status) === 401) {\n    var _error$config5;\n    // Check if this is a Salesforce endpoint error (invalid Salesforce credentials)\n    // vs an auth endpoint error (invalid user token)\n    const url = ((_error$config5 = error.config) === null || _error$config5 === void 0 ? void 0 : _error$config5.url) || '';\n    const isSalesforceEndpoint = url.includes('/salesforce/');\n    const isAuthEndpoint = url.includes('/auth/');\n\n    // Only redirect to login if it's an auth endpoint error (user token invalid)\n    // Salesforce 401 errors should not redirect - they're just invalid Salesforce credentials\n    if (isAuthEndpoint && !isSalesforceEndpoint) {\n      // Token expired or invalid - redirect to login\n      localStorage.removeItem('token');\n      window.location.href = '/login';\n    }\n    // For Salesforce endpoints, just return the error without redirecting\n  }\n  return Promise.reject(error);\n});\nexport default apiClient;","map":{"version":3,"names":["axios","API_BASE_URL","process","env","REACT_APP_API_URL","NODE_ENV","backendHealthCheckPromise","lastHealthCheck","HEALTH_CHECK_CACHE_MS","checkBackendHealthWithCache","now","Date","timestamp","isHealthy","healthUrl","response","get","timeout","validateStatus","status","error","csrfToken","csrfTokenPromise","getCsrfToken","baseURL","data","console","warn","apiClient","create","headers","interceptors","request","use","config","_config$url","_config$method","token","localStorage","getItem","Authorization","url","includes","method","toUpperCase","csrf","log","fullURL","hasToken","hasCsrfToken","tokenLength","length","window","location","origin","withCredentials","Promise","reject","checkBackendHealth","_error$response","_error$response3","_error$response4","_error$response5","_error$response5$data","_error$response5$data2","_error$response6","code","_error$config","_error$response2","message","isBackendDown","userMessage","_error$config2","isAuthEndpoint","_error$config3","_error$config4","name","originalRequest","_retry","newCsrfToken","csrfError","_error$config5","isSalesforceEndpoint","removeItem","href"],"sources":["/Users/mmoola/Documents/GitHub/project-tools/client/src/config/api.js"],"sourcesContent":["import axios from 'axios';\n\n// In development, use relative URL to go through proxy (avoids CORS)\n// In production, use full URL from environment variable\nconst API_BASE_URL = process.env.REACT_APP_API_URL || (process.env.NODE_ENV === 'production' ? '/api' : '/api');\n\n// Backend health check with retry logic\nlet backendHealthCheckPromise = null;\nlet lastHealthCheck = null;\nconst HEALTH_CHECK_CACHE_MS = 5000; // Cache health check for 5 seconds\n\nconst checkBackendHealthWithCache = async () => {\n  const now = Date.now();\n  \n  // Return cached result if available and recent\n  if (lastHealthCheck && (now - lastHealthCheck.timestamp) < HEALTH_CHECK_CACHE_MS) {\n    return lastHealthCheck.isHealthy;\n  }\n  \n  // If a health check is already in progress, wait for it\n  if (backendHealthCheckPromise) {\n    return backendHealthCheckPromise;\n  }\n  \n  // Start new health check\n  backendHealthCheckPromise = (async () => {\n    try {\n      // Health check endpoint - use relative path to go through proxy\n      const healthUrl = process.env.NODE_ENV === 'production' ? '/api/health' : '/api/health';\n      const response = await axios.get(healthUrl, {\n        timeout: 3000,\n        validateStatus: (status) => status === 200\n      });\n      lastHealthCheck = { isHealthy: true, timestamp: now };\n      return true;\n    } catch (error) {\n      lastHealthCheck = { isHealthy: false, timestamp: now };\n      return false;\n    } finally {\n      backendHealthCheckPromise = null;\n    }\n  })();\n  \n  return backendHealthCheckPromise;\n};\n\n// CSRF token management\nlet csrfToken = null;\nlet csrfTokenPromise = null;\n\nconst getCsrfToken = async () => {\n  // Return cached token if available\n  if (csrfToken) {\n    return csrfToken;\n  }\n  \n  // If a token fetch is already in progress, wait for it\n  if (csrfTokenPromise) {\n    return csrfTokenPromise;\n  }\n  \n  // Fetch new CSRF token\n  csrfTokenPromise = (async () => {\n    try {\n      const response = await axios.get('/csrf-token', {\n        baseURL: API_BASE_URL,\n        timeout: 5000\n      });\n      csrfToken = response.data.csrfToken;\n      return csrfToken;\n    } catch (error) {\n      console.warn('Failed to fetch CSRF token:', error);\n      // Return null if token fetch fails (will retry on next request)\n      return null;\n    } finally {\n      csrfTokenPromise = null;\n    }\n  })();\n  \n  return csrfTokenPromise;\n};\n\n// Create axios instance with default config\nconst apiClient = axios.create({\n  baseURL: API_BASE_URL,\n  headers: {\n    'Content-Type': 'application/json',\n  },\n  // Remove withCredentials to avoid CORS issues - server CORS is configured correctly\n  // withCredentials: true,\n  timeout: 120000, // 120 second timeout (increased for Salesforce API calls, especially KPIs)\n});\n\n// Request interceptor to add auth token and CSRF token\napiClient.interceptors.request.use(\n  async (config) => {\n    const token = localStorage.getItem('token');\n    if (token) {\n      config.headers.Authorization = `Bearer ${token}`;\n    }\n    \n    // Add CSRF token for state-changing requests (POST, PUT, DELETE, PATCH)\n    // Skip CSRF for auth endpoints and GET requests\n    if (!config.url?.includes('/auth/') && ['POST', 'PUT', 'DELETE', 'PATCH'].includes(config.method?.toUpperCase())) {\n      try {\n        const csrf = await getCsrfToken();\n        if (csrf) {\n          config.headers['X-CSRF-Token'] = csrf;\n        }\n      } catch (error) {\n        console.warn('Failed to get CSRF token for request:', error);\n      }\n    }\n    \n    // Always log request details in development for debugging\n    if (process.env.NODE_ENV === 'development') {\n      console.log('API Request:', {\n        url: config.url,\n        method: config.method,\n        baseURL: config.baseURL,\n        fullURL: `${config.baseURL}${config.url}`,\n        hasToken: !!token,\n        hasCsrfToken: !!config.headers['X-CSRF-Token'],\n        tokenLength: token ? token.length : 0,\n        headers: {\n          'Content-Type': config.headers['Content-Type'],\n          'Authorization': config.headers.Authorization ? 'Bearer ***' : 'None',\n          'X-CSRF-Token': config.headers['X-CSRF-Token'] ? '***' : 'None',\n          'Origin': window.location.origin\n        },\n        withCredentials: config.withCredentials\n      });\n    } else if (!token) {\n      console.warn('API Request without token:', {\n        url: config.url,\n        method: config.method\n      });\n    }\n    \n    return config;\n  },\n  (error) => {\n    console.error('Request interceptor error:', error);\n    return Promise.reject(error);\n  }\n);\n\n// Use the cached health check function\nconst checkBackendHealth = checkBackendHealthWithCache;\n\n// Export health check function for use in other modules\nexport { checkBackendHealth };\n\n// Response interceptor for error handling\napiClient.interceptors.response.use(\n  (response) => response,\n  async (error) => {\n    // Handle 504 Gateway Timeout errors\n    if (error.response?.status === 504 || error.code === 'ECONNREFUSED' || error.code === 'ETIMEDOUT') {\n      const url = error.config?.url || '';\n      console.error('Backend connection error:', {\n        status: error.response?.status,\n        code: error.code,\n        message: error.message,\n        url: url\n      });\n      \n      error.message = 'Backend server is not responding. Please ensure the server is running on port 5000.';\n      error.isBackendDown = true;\n      error.userMessage = 'Unable to connect to server. Please ensure the backend server is running on port 5000.';\n    }\n    \n    // Handle 404 errors - check if backend is ready\n    if (error.response?.status === 404) {\n      const url = error.config?.url || '';\n      const isAuthEndpoint = url.includes('/auth/');\n      \n      // For auth endpoints, check if backend is ready\n      if (isAuthEndpoint) {\n        const isHealthy = await checkBackendHealth();\n        if (!isHealthy) {\n          console.error('Backend is not responding. Please ensure the server is running on port 5000.');\n          error.message = 'Backend server is not responding. Please ensure the server is running on port 5000.';\n          error.isBackendDown = true;\n        } else {\n          console.error('404 on auth endpoint - route may not be registered:', url);\n          error.message = `Route not found: ${url}. Please check that the backend server has restarted and routes are registered.`;\n        }\n      }\n    }\n    \n    // Handle network errors (server not running, CORS blocked, etc.)\n    if (!error.response) {\n      const url = error.config?.url || '';\n      const baseURL = error.config?.baseURL || API_BASE_URL;\n      const fullURL = `${baseURL}${url}`;\n      \n      console.error('Network error - request did not reach server:', {\n        url: url,\n        fullURL: fullURL,\n        baseURL: baseURL,\n        message: error.message,\n        code: error.code,\n        name: error.name\n      });\n      \n      // Check if it's a CORS error\n      if (error.message && (\n        error.message.includes('CORS') || \n        error.message.includes('Network Error') ||\n        error.code === 'ERR_NETWORK' ||\n        error.code === 'ERR_BLOCKED_BY_CLIENT'\n      )) {\n        console.error('CORS or network blocking detected. Check:');\n        console.error('1. Server is running on port 5000');\n        console.error('2. CORS is configured correctly on server');\n        console.error('3. Browser is not blocking the request');\n        console.error('4. Request URL:', fullURL);\n      }\n      \n      const isAuthEndpoint = url.includes('/auth/');\n      \n      // For login/verify endpoints, provide helpful error message\n      if (isAuthEndpoint && (url.includes('/login') || url.includes('/verify'))) {\n        // Don't show error toast for network errors on login - let the component handle it\n        // The error will be caught in the login function and shown there\n      }\n      \n      return Promise.reject(error);\n    }\n    \n    // Handle CSRF token errors - refresh token and retry\n    if (error.response?.status === 403 && error.response?.data?.error?.includes('CSRF')) {\n      // Clear cached CSRF token and retry once\n      csrfToken = null;\n      const originalRequest = error.config;\n      \n      // Only retry if we haven't already retried\n      if (!originalRequest._retry) {\n        originalRequest._retry = true;\n        try {\n          const newCsrfToken = await getCsrfToken();\n          if (newCsrfToken && originalRequest.headers) {\n            originalRequest.headers['X-CSRF-Token'] = newCsrfToken;\n            return apiClient(originalRequest);\n          }\n        } catch (csrfError) {\n          console.error('Failed to refresh CSRF token:', csrfError);\n        }\n      }\n    }\n    \n    if (error.response?.status === 401) {\n      // Check if this is a Salesforce endpoint error (invalid Salesforce credentials)\n      // vs an auth endpoint error (invalid user token)\n      const url = error.config?.url || '';\n      const isSalesforceEndpoint = url.includes('/salesforce/');\n      const isAuthEndpoint = url.includes('/auth/');\n      \n      // Only redirect to login if it's an auth endpoint error (user token invalid)\n      // Salesforce 401 errors should not redirect - they're just invalid Salesforce credentials\n      if (isAuthEndpoint && !isSalesforceEndpoint) {\n        // Token expired or invalid - redirect to login\n        localStorage.removeItem('token');\n        window.location.href = '/login';\n      }\n      // For Salesforce endpoints, just return the error without redirecting\n    }\n    return Promise.reject(error);\n  }\n);\n\nexport default apiClient;\n\n\n\n\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}