{"ast":null,"code":"var _jsxFileName = \"/Users/mmoola/Documents/GitHub/project-tools/client/src/pages/ProjectManagement/PMApprovals/PMApprovals.js\",\n  _s = $RefreshSig$();\nimport React, { useState, useEffect, useCallback, useRef } from 'react';\nimport { useAuth } from '../../../context/AuthContext';\nimport Sidebar from '../../../components/Sidebar';\nimport useSidebarWidth from '../../../hooks/useSidebarWidth';\nimport { Menu, LogOut, RefreshCw, Loader, ChevronLeft, ChevronRight } from 'lucide-react';\nimport apiClient from '../../../config/api';\nimport toast from 'react-hot-toast';\nimport BookmarkButton from '../../../components/BookmarkButton';\nimport DeadlinesPanel from './components/DeadlinesPanel';\nimport RecordsCount from './components/RecordsCount';\nimport FieldFilter from './components/FieldFilter';\nimport PendingHoursCard from './components/PendingHoursCard';\nimport MetricsRow from './components/MetricsRow';\nimport PendingUnitsCard from './components/PendingUnitsCard';\nimport ApprovalsTable from './components/ApprovalsTable';\nimport ActionButtons from './components/ActionButtons';\nimport ApprovalModal from './components/ApprovalModal';\nimport RejectModal from './components/RejectModal';\nimport EmailModal from './components/EmailModal';\nimport './PMApprovals.css';\nimport '../../../styles/Sidebar.css';\nimport '../../../styles/GlobalHeader.css';\n\n// Map client-side field names to Salesforce field names for sorting\nimport { jsxDEV as _jsxDEV, Fragment as _Fragment } from \"react/jsx-dev-runtime\";\nconst mapSortFieldToSalesforce = clientFieldName => {\n  const fieldMap = {\n    'transactionId': 'Transaction_ID__c',\n    'contributorName': 'Contact__r.Name',\n    'email': 'Contact__r.Email',\n    'projectName': 'Contributor_Project__r.Project_Objective__r.Project__r.Name',\n    'projectObjectiveName': 'Project_Objective__r.Name',\n    'accountName': 'Contributor_Project__r.Project_Objective__r.Project__r.Account__r.Name',\n    'transactionDate': 'Transaction_Date__c',\n    'variancePercent': 'Variance_Percent__c',\n    'payrate': 'Payrate__c',\n    'totalPayment': 'Total_Payment__c',\n    'status': 'Status__c'\n  };\n  return fieldMap[clientFieldName] || clientFieldName; // Return as-is if not in map (might already be Salesforce field name)\n};\n\n// Map Salesforce field names back to client-side field names\nconst mapSalesforceToClientField = salesforceFieldName => {\n  const reverseMap = {\n    'Transaction_ID__c': 'transactionId',\n    'Contact__r.Name': 'contributorName',\n    'Contact__r.Email': 'email',\n    'Contributor_Project__r.Project_Objective__r.Project__r.Name': 'projectName',\n    'Project_Objective__r.Name': 'projectObjectiveName',\n    'Contributor_Project__r.Project_Objective__r.Project__r.Account__r.Name': 'accountName',\n    'Transaction_Date__c': 'transactionDate',\n    'Variance_Percent__c': 'variancePercent',\n    'Payrate__c': 'payrate',\n    'Total_Payment__c': 'totalPayment',\n    'Status__c': 'status'\n  };\n  return reverseMap[salesforceFieldName] || salesforceFieldName; // Return as-is if not in map\n};\n\n// Client-side sorting function\nconst sortRecords = (records, sortField, sortOrder) => {\n  if (!sortField || !Array.isArray(records) || records.length === 0) {\n    return records;\n  }\n  const sorted = [...records].sort((a, b) => {\n    let aValue = a[sortField];\n    let bValue = b[sortField];\n\n    // Handle null/undefined values\n    if (aValue == null) aValue = '';\n    if (bValue == null) bValue = '';\n\n    // Convert to strings for comparison if not already\n    const aStr = String(aValue).trim().toLowerCase();\n    const bStr = String(bValue).trim().toLowerCase();\n\n    // Try to parse as numbers for numeric fields\n    const numericFields = ['variancePercent', 'payrate', 'totalPayment', 'selfReportedHours', 'selfReportedUnits', 'systemTrackedHours', 'systemTrackedUnits'];\n    if (numericFields.includes(sortField)) {\n      const aNum = parseFloat(aValue) || 0;\n      const bNum = parseFloat(bValue) || 0;\n      return sortOrder === 'ASC' ? aNum - bNum : bNum - aNum;\n    }\n\n    // Try to parse as dates for date fields\n    if (sortField === 'transactionDate') {\n      const aDate = aValue ? new Date(aValue).getTime() : 0;\n      const bDate = bValue ? new Date(bValue).getTime() : 0;\n      return sortOrder === 'ASC' ? aDate - bDate : bDate - aDate;\n    }\n\n    // String comparison\n    if (aStr < bStr) return sortOrder === 'ASC' ? -1 : 1;\n    if (aStr > bStr) return sortOrder === 'ASC' ? 1 : -1;\n    return 0;\n  });\n  return sorted;\n};\nconst PMApprovals = () => {\n  _s();\n  const {\n    user,\n    logout\n  } = useAuth();\n  const [sidebarOpen, setSidebarOpen] = useState(true);\n  const sidebarWidth = useSidebarWidth(sidebarOpen);\n  const [leftPanelCollapsed, setLeftPanelCollapsed] = useState(false);\n  const [loading, setLoading] = useState(true);\n  const [refreshing, setRefreshing] = useState(false);\n\n  // Data states\n  const [records, setRecords] = useState([]);\n  const [summary, setSummary] = useState(null);\n  const [deadlines, setDeadlines] = useState(null);\n  // Filter states - field-based filtering\n  const [filter, setFilter] = useState({\n    field: '',\n    value: ''\n  });\n  const [sortBy, setSortBy] = useState('transactionDate');\n  const [sortOrder, setSortOrder] = useState('DESC');\n\n  // Table states\n  const [offset, setOffset] = useState(0);\n  const [hasMore, setHasMore] = useState(true);\n  const [loadingMore, setLoadingMore] = useState(false);\n  const [totalRecords, setTotalRecords] = useState(0);\n  const [uniqueRecordsCount, setUniqueRecordsCount] = useState(0);\n  const [duplicatesCount, setDuplicatesCount] = useState(0);\n  const [selectedRows, setSelectedRows] = useState([]);\n\n  // Modal states\n  const [showApprovalModal, setShowApprovalModal] = useState(false);\n  const [showRejectModal, setShowRejectModal] = useState(false);\n  const [showEmailModal, setShowEmailModal] = useState(false);\n\n  // Track if warning has been shown to avoid duplicates\n  const warningShownRef = useRef(false);\n\n  // Track if auto-loading is in progress\n  const autoLoadingRef = useRef(false);\n\n  // Track current records to avoid stale closures\n  const recordsRef = useRef([]);\n\n  // Map-based record storage for O(1) lookup and guaranteed uniqueness\n  const recordsMapRef = useRef(new Map());\n\n  // Track total unique records loaded (for display and comparison)\n  const uniqueRecordsCountRef = useRef(0);\n\n  // Track total duplicates filtered out across all batches\n  const totalDuplicatesRef = useRef(0);\n\n  // Track total records received from server (including duplicates)\n  const totalRecordsReceivedRef = useRef(0);\n  const tableContainerRef = useRef(null);\n\n  // Keep recordsRef and recordsMapRef in sync with records state\n  useEffect(() => {\n    // Ensure records is always an array\n    const recordsArray = Array.isArray(records) ? records : [];\n    recordsRef.current = recordsArray;\n    // Update map whenever records change\n    const newMap = new Map();\n    recordsArray.forEach(record => {\n      if (record && record.id) {\n        newMap.set(record.id, record);\n      }\n    });\n    recordsMapRef.current = newMap;\n  }, [records]);\n\n  // Fetch deadlines\n  const fetchDeadlines = useCallback(async () => {\n    try {\n      const response = await apiClient.get('/pm-approvals/deadlines');\n      if (response.data.success) {\n        setDeadlines(response.data.deadlines);\n      }\n    } catch (error) {\n      console.error('Error fetching deadlines:', error);\n    }\n  }, []);\n\n  // Fetch filter options\n  // No longer need to fetch filter options - values come from table data\n\n  // Fetch summary metrics\n  const fetchSummary = useCallback(async (silent = false) => {\n    try {\n      const params = new URLSearchParams();\n      // For summary, use the filter if available (server-side filters only)\n      if (filter && filter.field && filter.value && !['accountName', 'projectName'].includes(filter.field)) {\n        params.append('filterField', filter.field);\n        params.append('filterValue', filter.value);\n      }\n      const response = await apiClient.get(`/pm-approvals/summary?${params.toString()}`);\n      if (response.data.success) {\n        setSummary(response.data.data);\n        if (response.data.warning && !silent && !warningShownRef.current) {\n          warningShownRef.current = true;\n          toast(response.data.warning, {\n            duration: 8000,\n            icon: 'âš ï¸',\n            style: {\n              background: '#fffbeb',\n              color: '#92400e',\n              border: '1px solid #fde68a'\n            }\n          });\n        }\n      }\n    } catch (error) {\n      console.error('Error fetching summary:', error);\n      if (!silent && error.code !== 'ECONNREFUSED' && error.code !== 'ERR_NETWORK' && !error.isBackendDown) {\n        toast.error('Failed to load summary metrics');\n      }\n    }\n  }, [filter]);\n\n  // Simplified fetch records function - loads 5000 records per batch\n  const fetchRecords = useCallback(async (reset = false, startOffset = null, filterOverride = null, sortByOverride = null, sortOrderOverride = null) => {\n    // Prevent concurrent fetches\n    if (autoLoadingRef.current && !reset) {\n      return;\n    }\n    autoLoadingRef.current = true;\n\n    // Use filterOverride if provided, otherwise use current filter state\n    const activeFilter = filterOverride !== null ? filterOverride : filter;\n    // Use sort overrides if provided, otherwise use current sort state\n    const activeSortBy = sortByOverride !== null ? sortByOverride : sortBy;\n    const activeSortOrder = sortOrderOverride !== null ? sortOrderOverride : sortOrder;\n    if (reset) {\n      setLoading(true);\n      setRecords([]);\n      recordsRef.current = [];\n      recordsMapRef.current = new Map(); // Reset map\n      uniqueRecordsCountRef.current = 0; // Reset unique count\n      totalDuplicatesRef.current = 0; // Reset duplicates count\n      totalRecordsReceivedRef.current = 0; // Reset total received\n      setOffset(0);\n      setTotalRecords(0);\n      setUniqueRecordsCount(0);\n      setDuplicatesCount(0);\n      setHasMore(true);\n      autoLoadingRef.current = false; // Allow reset to proceed\n    } else {\n      setLoadingMore(true);\n    }\n    try {\n      const currentOffset = startOffset !== null ? startOffset : offset;\n      const params = new URLSearchParams();\n      params.append('offset', currentOffset.toString());\n      params.append('limit', '5000'); // Request 5,000 records per batch\n      // Map client-side field name to Salesforce field name for server query\n      const salesforceSortBy = mapSortFieldToSalesforce(activeSortBy) || 'Transaction_Date__c';\n      params.append('sortBy', salesforceSortBy);\n      params.append('sortOrder', activeSortOrder);\n\n      // Add field-based filter parameters\n      if (activeFilter && activeFilter.field && activeFilter.value) {\n        params.append('filterField', activeFilter.field);\n        params.append('filterValue', activeFilter.value);\n      }\n      console.log('PM Approvals - Fetching records with filter:', activeFilter);\n      console.log('PM Approvals - Query params:', params.toString());\n      const response = await apiClient.get(`/pm-approvals/list?${params.toString()}`);\n      if (response.data.success) {\n        // Ensure records is an array\n        const recordsData = response.data.records;\n        const newRecords = Array.isArray(recordsData) ? recordsData : [];\n        const total = response.data.total || 0;\n        const effectiveOffset = response.data.effectiveOffset !== undefined ? response.data.effectiveOffset : currentOffset + newRecords.length;\n        const hasMoreData = response.data.hasMore || false;\n        setTotalRecords(total);\n\n        // SYSTEMATIC DEDUPLICATION: Use Map-based approach for guaranteed uniqueness\n        if (reset) {\n          // Reset: Build new map from scratch\n          const recordsMap = new Map();\n          const uniqueRecords = [];\n          let duplicateCount = 0;\n          newRecords.forEach(record => {\n            if (record && record.id) {\n              // Only add if not already in map (guarantees uniqueness)\n              if (!recordsMap.has(record.id)) {\n                recordsMap.set(record.id, record);\n                uniqueRecords.push(record);\n              } else {\n                duplicateCount++;\n                console.warn(`Duplicate record detected during reset: ${record.id}`);\n              }\n            }\n          });\n          recordsMapRef.current = recordsMap;\n          setRecords(uniqueRecords);\n          recordsRef.current = uniqueRecords;\n          uniqueRecordsCountRef.current = uniqueRecords.length;\n          totalRecordsReceivedRef.current = newRecords.length;\n\n          // Calculate duplicates consistently: total received - unique count\n          // This ensures the count is always accurate regardless of batch order\n          const calculatedDuplicates = totalRecordsReceivedRef.current - uniqueRecordsCountRef.current;\n          totalDuplicatesRef.current = calculatedDuplicates;\n          setUniqueRecordsCount(uniqueRecords.length);\n          setDuplicatesCount(calculatedDuplicates);\n          setOffset(uniqueRecords.length);\n          if (newRecords.length !== uniqueRecords.length) {\n            console.warn(`Deduplication: ${newRecords.length} records received, ${uniqueRecords.length} unique records after deduplication, ${calculatedDuplicates} duplicates filtered`);\n          }\n\n          // Check if we have more records to load (for reset case)\n          // Continue loading as long as server says hasMore=true, regardless of unique count\n          // This ensures we process all batches to find all unique records\n          const stillHasMoreReset = hasMoreData && newRecords.length > 0;\n          setHasMore(stillHasMoreReset);\n          console.log(`Batch loaded (reset): offset=0, received=${newRecords.length}, unique=${uniqueRecords.length}, totalUnique=${uniqueRecordsCountRef.current}, serverTotal=${total}, hasMore=${stillHasMoreReset}`);\n\n          // Auto-load next batch if server indicates more records available\n          // We continue loading even if all records in this batch were duplicates,\n          // because there might be more unique records in subsequent batches\n          if (stillHasMoreReset) {\n            setTimeout(() => {\n              fetchRecords(false, effectiveOffset).catch(err => {\n                console.error('Error auto-loading next batch:', err);\n                setHasMore(false);\n              });\n            }, 50); // Small delay to keep UI responsive\n          } else {\n            if (newRecords.length === 0) {\n              console.log('Stopping auto-load (reset): No records received from API');\n            } else {\n              console.log(`All records loaded (reset): Loaded ${uniqueRecordsCountRef.current} unique records from ${total} total records`);\n            }\n            setHasMore(false);\n          }\n        } else {\n          // Append: Use functional update with Map-based deduplication\n          let uniqueNewRecordsCount = 0;\n          setRecords(prev => {\n            // Get current map for O(1) lookup\n            const currentMap = recordsMapRef.current;\n            const uniqueNewRecords = [];\n            let duplicateCount = 0;\n            newRecords.forEach(record => {\n              if (record && record.id) {\n                if (!currentMap.has(record.id)) {\n                  // New record - add to map and list\n                  currentMap.set(record.id, record);\n                  uniqueNewRecords.push(record);\n                } else {\n                  // Duplicate detected\n                  duplicateCount++;\n                  console.warn(`Duplicate record detected during append: ${record.id}`);\n                }\n              }\n            });\n\n            // Track how many unique records were actually added\n            uniqueNewRecordsCount = uniqueNewRecords.length;\n\n            // Update total duplicates and total received\n            totalDuplicatesRef.current += duplicateCount;\n            totalRecordsReceivedRef.current += newRecords.length;\n            if (duplicateCount > 0) {\n              console.warn(`Deduplication: ${duplicateCount} duplicate(s) filtered out from ${newRecords.length} new records`);\n            }\n\n            // Build new array from map values to ensure no duplicates\n            const updatedRecords = Array.from(currentMap.values());\n            recordsMapRef.current = currentMap;\n            recordsRef.current = updatedRecords;\n            uniqueRecordsCountRef.current = updatedRecords.length; // Update unique count\n\n            // Calculate duplicates consistently: total received - unique count\n            // This ensures the count is always accurate regardless of batch order\n            const calculatedDuplicates = totalRecordsReceivedRef.current - uniqueRecordsCountRef.current;\n\n            // Update state for display - use calculated duplicates for consistency\n            setUniqueRecordsCount(updatedRecords.length);\n            setDuplicatesCount(calculatedDuplicates);\n\n            // Also update the ref to keep it in sync\n            totalDuplicatesRef.current = calculatedDuplicates;\n            return updatedRecords;\n          });\n          setOffset(effectiveOffset);\n\n          // Check if we have more records to load\n          // IMPORTANT: Continue loading as long as server says hasMore=true\n          // This ensures we process all batches to find all unique records, even if\n          // some batches contain only duplicates\n          // Only stop if:\n          // 1. Server says hasMore=false (no more batches)\n          // 2. We received 0 records from API (end of data)\n          const stillHasMore = hasMoreData && newRecords.length > 0;\n          setHasMore(stillHasMore);\n          console.log(`Batch loaded: offset=${currentOffset}, received=${newRecords.length}, unique=${uniqueNewRecordsCount}, totalUnique=${uniqueRecordsCountRef.current}, effectiveOffset=${effectiveOffset}, serverTotal=${total}, hasMore=${stillHasMore}`);\n\n          // Auto-load next batch if server indicates more records available\n          // Continue loading even if all records in this batch were duplicates,\n          // because there might be more unique records in subsequent batches\n          if (stillHasMore) {\n            setTimeout(() => {\n              fetchRecords(false, effectiveOffset).catch(err => {\n                console.error('Error auto-loading next batch:', err);\n                setHasMore(false);\n              });\n            }, 50); // Small delay to keep UI responsive\n          } else {\n            if (newRecords.length === 0) {\n              console.log('Stopping auto-load: No records received from API');\n            } else {\n              console.log(`All records loaded: Loaded ${uniqueRecordsCountRef.current} unique records from ${total} total records`);\n            }\n            setHasMore(false);\n          }\n        }\n        if (response.data.warning && reset && !warningShownRef.current) {\n          warningShownRef.current = true;\n          toast(response.data.warning, {\n            duration: 8000,\n            icon: 'âš ï¸',\n            style: {\n              background: '#fffbeb',\n              color: '#92400e',\n              border: '1px solid #fde68a'\n            }\n          });\n        }\n      } else {\n        toast.error(response.data.error || 'Failed to fetch approvals');\n        setHasMore(false);\n      }\n    } catch (error) {\n      console.error('Error fetching records:', error);\n      if (error.code !== 'ECONNREFUSED' && error.code !== 'ERR_NETWORK' && !error.isBackendDown) {\n        toast.error('Failed to fetch approvals');\n      }\n      setHasMore(false);\n    } finally {\n      setLoading(false);\n      setLoadingMore(false);\n      setRefreshing(false);\n      autoLoadingRef.current = false;\n    }\n  }, [filter, sortBy, sortOrder, offset]);\n\n  // Track if initial load has been done\n  const initialLoadDoneRef = useRef(false);\n\n  // Initial load - only runs once on mount\n  useEffect(() => {\n    if (!initialLoadDoneRef.current) {\n      initialLoadDoneRef.current = true;\n      fetchDeadlines();\n      fetchSummary(true);\n      fetchRecords(true);\n    }\n  }, [fetchDeadlines, fetchSummary, fetchRecords]);\n\n  // Normalize sortBy to always use client-side field names (only if it's a Salesforce field name)\n  useEffect(() => {\n    const clientSortField = mapSalesforceToClientField(sortBy);\n    // Only update if it's actually a Salesforce field name (mapping changed it)\n    // This prevents infinite loops since if it's already a client-side name, clientSortField === sortBy\n    if (clientSortField !== sortBy && sortBy) {\n      console.log(`Normalizing sortBy from Salesforce field \"${sortBy}\" to client-side field \"${clientSortField}\"`);\n      setSortBy(clientSortField);\n    }\n  }, [sortBy]);\n\n  // Note: Filters and sort changes no longer trigger data reset\n  // Data persists during the session and only reloads when refresh button is clicked\n\n  const handleRefresh = useCallback(e => {\n    if (e) {\n      e.preventDefault();\n      e.stopPropagation();\n    }\n    setRefreshing(true);\n    setOffset(0);\n    setRecords([]);\n    recordsRef.current = [];\n    setHasMore(true);\n    setSelectedRows([]);\n    setTotalRecords(0);\n    warningShownRef.current = false;\n    autoLoadingRef.current = false;\n    fetchRecords(true).finally(() => {\n      setRefreshing(false);\n    });\n    fetchSummary();\n  }, [fetchRecords, fetchSummary]);\n  const handleApplyFilter = useCallback(filterData => {\n    // Handle new structure from FieldFilter: { filters: [...], sortBy: '', sortOrder: '' }\n    // or old structure: { field: '', value: '' }\n    let activeFilter = null;\n    let newSortBy = sortBy;\n    let newSortOrder = sortOrder;\n    let needsRefetch = false;\n\n    // Check if it's the new structure (from FieldFilter)\n    if (filterData.filters !== undefined) {\n      // New structure: { filters: [...], sortBy: '', sortOrder: '' }\n      const activeFilters = filterData.filters.filter(f => f.field && f.value);\n      if (activeFilters.length > 0) {\n        // Use the first filter for now (supporting single filter)\n        activeFilter = activeFilters[0];\n      }\n\n      // Update sort if provided\n      if (filterData.sortBy !== undefined) {\n        // Map client-side field name to Salesforce field name\n        const clientSortField = filterData.sortBy || 'transactionDate';\n        newSortBy = mapSortFieldToSalesforce(clientSortField) || 'Transaction_Date__c';\n        needsRefetch = true;\n      }\n      if (filterData.sortOrder !== undefined) {\n        newSortOrder = filterData.sortOrder || 'DESC';\n        needsRefetch = true;\n      }\n    } else {\n      // Old structure: { field: '', value: '' }\n      activeFilter = filterData;\n    }\n\n    // Update sort state if changed\n    if (newSortBy !== sortBy || newSortOrder !== sortOrder) {\n      setSortBy(newSortBy);\n      setSortOrder(newSortOrder);\n      // No need to refetch - sorting is now client-side\n    }\n\n    // ALL filtering is now client-side - just update the filter state\n    if (activeFilter) {\n      setFilter(activeFilter);\n      setSelectedRows([]);\n      console.log('PM Approvals - Applying client-side filter:', activeFilter);\n    } else if (needsRefetch && !activeFilter) {\n      // Only sort changed, no filter - just update sort state (already done above)\n      setSelectedRows([]);\n      console.log('PM Approvals - Applying client-side sort:', {\n        sortBy: newSortBy,\n        sortOrder: newSortOrder\n      });\n    }\n  }, [fetchRecords, fetchSummary, sortBy, sortOrder]);\n  const handleClearFilter = useCallback(() => {\n    // All filtering is client-side - just clear the filter and sort state\n    setFilter({\n      field: '',\n      value: ''\n    });\n    setSortBy('transactionDate');\n    setSortOrder('DESC');\n    setSelectedRows([]);\n    console.log('PM Approvals - Clearing client-side filter and sort');\n    // No server refetch needed - filtering and sorting are client-side\n  }, []);\n  const handleSort = useCallback((column, order) => {\n    // Use client-side field name directly for client-side sorting\n    const clientField = column || 'transactionDate';\n    const newSortBy = clientField;\n    const newSortOrder = order || 'DESC';\n    setSortBy(newSortBy);\n    setSortOrder(newSortOrder);\n    setSelectedRows([]);\n    console.log('PM Approvals - Applying client-side sort:', {\n      field: newSortBy,\n      order: newSortOrder\n    });\n    // No server refetch needed - sorting is now client-side\n  }, []);\n  const handleRowSelect = recordId => {\n    setSelectedRows(prev => {\n      if (prev.includes(recordId)) {\n        return prev.filter(id => id !== recordId);\n      } else {\n        return [...prev, recordId];\n      }\n    });\n  };\n  const handleApprove = () => {\n    if (selectedRows.length === 0) {\n      toast.error('Please select at least one record to approve');\n      return;\n    }\n    setShowApprovalModal(true);\n  };\n  const handleReject = () => {\n    if (selectedRows.length === 0) {\n      toast.error('Please select at least one record to reject');\n      return;\n    }\n    setShowRejectModal(true);\n  };\n  const handleSendEmail = () => {\n    if (selectedRows.length === 0) {\n      toast.error('Please select at least one record to email');\n      return;\n    }\n    setShowEmailModal(true);\n  };\n  const handleApprovalConfirm = async comment => {\n    try {\n      const response = await apiClient.post('/pm-approvals/approve', {\n        transactionIds: selectedRows,\n        comment: comment || ''\n      });\n      if (response.data.success) {\n        toast.success(`Successfully approved ${response.data.approved} record(s)`);\n        setRecords(prev => {\n          const filtered = prev.filter(r => !selectedRows.includes(r.id));\n          // Update map to match filtered records\n          const newMap = new Map();\n          filtered.forEach(record => {\n            if (record && record.id) {\n              newMap.set(record.id, record);\n            }\n          });\n          recordsMapRef.current = newMap;\n          recordsRef.current = filtered;\n          return filtered;\n        });\n        setSelectedRows([]);\n        setShowApprovalModal(false);\n        fetchSummary();\n      } else {\n        toast.error(response.data.error || 'Failed to approve records');\n      }\n    } catch (error) {\n      var _error$response, _error$response$data;\n      toast.error(((_error$response = error.response) === null || _error$response === void 0 ? void 0 : (_error$response$data = _error$response.data) === null || _error$response$data === void 0 ? void 0 : _error$response$data.error) || 'Failed to approve records');\n    }\n  };\n  const handleRejectConfirm = async reason => {\n    try {\n      const response = await apiClient.post('/pm-approvals/reject', {\n        transactionIds: selectedRows,\n        reason: reason || ''\n      });\n      if (response.data.success) {\n        toast.success(`Successfully rejected ${response.data.rejected} record(s)`);\n        setRecords(prev => {\n          const filtered = prev.filter(r => !selectedRows.includes(r.id));\n          // Update map to match filtered records\n          const newMap = new Map();\n          filtered.forEach(record => {\n            if (record && record.id) {\n              newMap.set(record.id, record);\n            }\n          });\n          recordsMapRef.current = newMap;\n          recordsRef.current = filtered;\n          return filtered;\n        });\n        setSelectedRows([]);\n        setShowRejectModal(false);\n        fetchSummary();\n      } else {\n        toast.error(response.data.error || 'Failed to reject records');\n      }\n    } catch (error) {\n      var _error$response2, _error$response2$data;\n      toast.error(((_error$response2 = error.response) === null || _error$response2 === void 0 ? void 0 : (_error$response2$data = _error$response2.data) === null || _error$response2$data === void 0 ? void 0 : _error$response2$data.error) || 'Failed to reject records');\n    }\n  };\n  const handleEmailConfirm = async emailData => {\n    toast.info('Email functionality coming soon');\n    setShowEmailModal(false);\n  };\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    className: \"dashboard-layout\",\n    children: [/*#__PURE__*/_jsxDEV(Sidebar, {\n      isOpen: sidebarOpen,\n      toggleSidebar: () => setSidebarOpen(!sidebarOpen)\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 701,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n      className: \"pm-approvals-page\",\n      style: {\n        marginLeft: `${sidebarWidth}px`,\n        width: `calc(100% - ${sidebarWidth}px)`,\n        transition: 'margin-left 0.2s ease, width 0.2s ease'\n      },\n      children: /*#__PURE__*/_jsxDEV(\"div\", {\n        className: \"pm-approvals-container\",\n        children: [/*#__PURE__*/_jsxDEV(\"div\", {\n          className: \"pm-approvals-header\",\n          children: /*#__PURE__*/_jsxDEV(\"div\", {\n            className: \"header-content\",\n            children: [/*#__PURE__*/_jsxDEV(\"div\", {\n              className: \"header-left\",\n              children: [/*#__PURE__*/_jsxDEV(\"button\", {\n                className: \"header-menu-toggle\",\n                onClick: () => setSidebarOpen(!sidebarOpen),\n                \"aria-label\": \"Toggle sidebar\",\n                children: /*#__PURE__*/_jsxDEV(Menu, {\n                  size: 20\n                }, void 0, false, {\n                  fileName: _jsxFileName,\n                  lineNumber: 721,\n                  columnNumber: 19\n                }, this)\n              }, void 0, false, {\n                fileName: _jsxFileName,\n                lineNumber: 716,\n                columnNumber: 17\n              }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n                children: /*#__PURE__*/_jsxDEV(\"h1\", {\n                  className: \"page-title\",\n                  children: \"PM Approvals for Self Reported Time\"\n                }, void 0, false, {\n                  fileName: _jsxFileName,\n                  lineNumber: 724,\n                  columnNumber: 19\n                }, this)\n              }, void 0, false, {\n                fileName: _jsxFileName,\n                lineNumber: 723,\n                columnNumber: 17\n              }, this)]\n            }, void 0, true, {\n              fileName: _jsxFileName,\n              lineNumber: 715,\n              columnNumber: 15\n            }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n              className: \"header-right\",\n              children: [/*#__PURE__*/_jsxDEV(BookmarkButton, {}, void 0, false, {\n                fileName: _jsxFileName,\n                lineNumber: 728,\n                columnNumber: 17\n              }, this), /*#__PURE__*/_jsxDEV(\"button\", {\n                className: \"refresh-btn\",\n                onClick: handleRefresh,\n                disabled: refreshing,\n                title: \"Refresh\",\n                children: /*#__PURE__*/_jsxDEV(RefreshCw, {\n                  size: 18,\n                  className: refreshing ? 'spinning' : ''\n                }, void 0, false, {\n                  fileName: _jsxFileName,\n                  lineNumber: 735,\n                  columnNumber: 19\n                }, this)\n              }, void 0, false, {\n                fileName: _jsxFileName,\n                lineNumber: 729,\n                columnNumber: 17\n              }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n                className: \"header-user-profile\",\n                children: /*#__PURE__*/_jsxDEV(\"div\", {\n                  className: \"user-profile\",\n                  children: [/*#__PURE__*/_jsxDEV(\"div\", {\n                    className: \"user-avatar\",\n                    children: ((user === null || user === void 0 ? void 0 : user.email) || 'U').charAt(0).toUpperCase()\n                  }, void 0, false, {\n                    fileName: _jsxFileName,\n                    lineNumber: 739,\n                    columnNumber: 21\n                  }, this), /*#__PURE__*/_jsxDEV(\"span\", {\n                    className: \"user-name\",\n                    children: (user === null || user === void 0 ? void 0 : user.email) || 'User'\n                  }, void 0, false, {\n                    fileName: _jsxFileName,\n                    lineNumber: 742,\n                    columnNumber: 21\n                  }, this), /*#__PURE__*/_jsxDEV(\"button\", {\n                    className: \"logout-btn\",\n                    onClick: logout,\n                    title: \"Logout\",\n                    children: /*#__PURE__*/_jsxDEV(LogOut, {\n                      size: 18\n                    }, void 0, false, {\n                      fileName: _jsxFileName,\n                      lineNumber: 744,\n                      columnNumber: 23\n                    }, this)\n                  }, void 0, false, {\n                    fileName: _jsxFileName,\n                    lineNumber: 743,\n                    columnNumber: 21\n                  }, this)]\n                }, void 0, true, {\n                  fileName: _jsxFileName,\n                  lineNumber: 738,\n                  columnNumber: 19\n                }, this)\n              }, void 0, false, {\n                fileName: _jsxFileName,\n                lineNumber: 737,\n                columnNumber: 17\n              }, this)]\n            }, void 0, true, {\n              fileName: _jsxFileName,\n              lineNumber: 727,\n              columnNumber: 15\n            }, this)]\n          }, void 0, true, {\n            fileName: _jsxFileName,\n            lineNumber: 714,\n            columnNumber: 13\n          }, this)\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 713,\n          columnNumber: 11\n        }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n          className: \"pm-approvals-content\",\n          children: [/*#__PURE__*/_jsxDEV(\"div\", {\n            className: `pm-approvals-sidebar ${leftPanelCollapsed ? 'collapsed' : ''}`,\n            children: [/*#__PURE__*/_jsxDEV(\"button\", {\n              className: \"left-panel-toggle\",\n              onClick: () => setLeftPanelCollapsed(!leftPanelCollapsed),\n              \"aria-label\": leftPanelCollapsed ? 'Expand left panel' : 'Collapse left panel',\n              title: leftPanelCollapsed ? 'Expand left panel' : 'Collapse left panel',\n              children: leftPanelCollapsed ? /*#__PURE__*/_jsxDEV(ChevronRight, {\n                size: 18\n              }, void 0, false, {\n                fileName: _jsxFileName,\n                lineNumber: 762,\n                columnNumber: 39\n              }, this) : /*#__PURE__*/_jsxDEV(ChevronLeft, {\n                size: 18\n              }, void 0, false, {\n                fileName: _jsxFileName,\n                lineNumber: 762,\n                columnNumber: 68\n              }, this)\n            }, void 0, false, {\n              fileName: _jsxFileName,\n              lineNumber: 756,\n              columnNumber: 15\n            }, this), !leftPanelCollapsed && /*#__PURE__*/_jsxDEV(_Fragment, {\n              children: [/*#__PURE__*/_jsxDEV(DeadlinesPanel, {\n                deadlines: deadlines,\n                loading: !deadlines\n              }, void 0, false, {\n                fileName: _jsxFileName,\n                lineNumber: 766,\n                columnNumber: 19\n              }, this), /*#__PURE__*/_jsxDEV(RecordsCount, {\n                count: (() => {\n                  // If client-side filtering is active, show filtered count (works for all fields now)\n                  if (filter.field && filter.value) {\n                    const filteredCount = records.filter(record => {\n                      if (!record) return false;\n                      const fieldValue = String(record[filter.field] || '').trim();\n                      const filterValue = String(filter.value || '').trim();\n                      return fieldValue === filterValue;\n                    }).length;\n                    return filteredCount;\n                  }\n                  return uniqueRecordsCount > 0 ? uniqueRecordsCount : records.length;\n                })(),\n                total: uniqueRecordsCount > 0 ? uniqueRecordsCount : records.length,\n                duplicates: duplicatesCount || 0,\n                loading: loading,\n                isLoadingMore: loadingMore || hasMore\n              }, void 0, false, {\n                fileName: _jsxFileName,\n                lineNumber: 767,\n                columnNumber: 19\n              }, this), /*#__PURE__*/_jsxDEV(FieldFilter, {\n                records: records,\n                onApplyFilter: handleApplyFilter,\n                onClearFilter: handleClearFilter,\n                loading: loading,\n                currentSortBy: sortBy,\n                currentSortOrder: sortOrder,\n                onSortChange: handleSort\n              }, void 0, false, {\n                fileName: _jsxFileName,\n                lineNumber: 786,\n                columnNumber: 15\n              }, this), /*#__PURE__*/_jsxDEV(ActionButtons, {\n                onApprove: handleApprove,\n                onReject: handleReject,\n                onSendEmail: handleSendEmail,\n                disabled: loading,\n                selectedCount: selectedRows.length\n              }, void 0, false, {\n                fileName: _jsxFileName,\n                lineNumber: 795,\n                columnNumber: 19\n              }, this)]\n            }, void 0, true)]\n          }, void 0, true, {\n            fileName: _jsxFileName,\n            lineNumber: 755,\n            columnNumber: 13\n          }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n            className: \"pm-approvals-main\",\n            ref: tableContainerRef,\n            children: [/*#__PURE__*/_jsxDEV(\"div\", {\n              className: \"summary-metrics-section\",\n              children: (() => {\n                // Calculate summary from filtered records if filter is applied\n                let calculatedSummary = null;\n                if (filter.field && filter.value) {\n                  const filteredRecords = Array.isArray(records) ? records.filter(record => {\n                    if (!record) return false;\n                    const fieldValue = String(record[filter.field] || '').trim();\n                    const filterValue = String(filter.value || '').trim();\n                    return fieldValue === filterValue;\n                  }) : [];\n                  calculatedSummary = filteredRecords.reduce((acc, record) => {\n                    const selfReportedHours = parseFloat(record.selfReportedHours) || 0;\n                    const systemTrackedHours = parseFloat(record.systemTrackedHours) || 0;\n                    const selfReportedUnits = parseFloat(record.selfReportedUnits) || 0;\n                    const totalPayment = parseFloat(record.totalPayment) || 0;\n                    acc.totalPendingHours += selfReportedHours;\n                    acc.totalHours += systemTrackedHours;\n                    acc.selfReportedTime += selfReportedHours;\n                    acc.systemTracked += systemTrackedHours;\n                    acc.totalPayment += totalPayment;\n                    acc.totalPendingUnits += selfReportedUnits;\n                    return acc;\n                  }, {\n                    totalPendingHours: 0,\n                    totalHours: 0,\n                    selfReportedTime: 0,\n                    systemTracked: 0,\n                    totalPayment: 0,\n                    totalPendingUnits: 0\n                  });\n                }\n\n                // Use calculated summary if filter is applied, otherwise use server summary\n                const displaySummary = calculatedSummary || summary || {};\n                return /*#__PURE__*/_jsxDEV(_Fragment, {\n                  children: [/*#__PURE__*/_jsxDEV(PendingHoursCard, {\n                    totalPendingHours: displaySummary.totalPendingHours || 0,\n                    totalHours: displaySummary.totalHours || 0\n                  }, void 0, false, {\n                    fileName: _jsxFileName,\n                    lineNumber: 850,\n                    columnNumber: 23\n                  }, this), /*#__PURE__*/_jsxDEV(MetricsRow, {\n                    selfReportedTime: displaySummary.selfReportedTime || 0,\n                    systemTracked: displaySummary.systemTracked || 0,\n                    payment: displaySummary.totalPayment || 0\n                  }, void 0, false, {\n                    fileName: _jsxFileName,\n                    lineNumber: 854,\n                    columnNumber: 23\n                  }, this), /*#__PURE__*/_jsxDEV(PendingUnitsCard, {\n                    totalPendingUnits: displaySummary.totalPendingUnits || 0\n                  }, void 0, false, {\n                    fileName: _jsxFileName,\n                    lineNumber: 859,\n                    columnNumber: 23\n                  }, this)]\n                }, void 0, true);\n              })()\n            }, void 0, false, {\n              fileName: _jsxFileName,\n              lineNumber: 809,\n              columnNumber: 15\n            }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n              className: \"approvals-table-section\",\n              children: /*#__PURE__*/_jsxDEV(ApprovalsTable, {\n                records: (() => {\n                  // Apply client-side filtering and sorting for all fields\n                  let processedRecords = Array.isArray(records) ? records : [];\n\n                  // Apply filtering for all fields\n                  if (filter.field && filter.value) {\n                    processedRecords = processedRecords.filter(record => {\n                      if (!record) return false;\n                      const fieldValue = String(record[filter.field] || '').trim();\n                      const filterValue = String(filter.value || '').trim();\n                      return fieldValue === filterValue;\n                    });\n                    console.log(`PM Approvals - Client-side filter applied: ${filter.field} = \"${filter.value}\", ${processedRecords.length} records match`);\n\n                    // Debug logging for specific transaction IDs\n                    if (filter.field === 'transactionId' && ['123028', '123029', '123030', '123031'].includes(filter.value)) {\n                      processedRecords.forEach(record => {\n                        console.log(`ðŸ” CLIENT DEBUG - Record for Transaction ID ${filter.value}:`, {\n                          transactionId: record.transactionId,\n                          contributorName: record.contributorName || '(empty)',\n                          email: record.email || '(empty)',\n                          projectObjectiveName: record.projectObjectiveName || '(empty)',\n                          projectName: record.projectName || '(empty)',\n                          accountName: record.accountName || '(empty)',\n                          transactionDate: record.transactionDate,\n                          allKeys: Object.keys(record)\n                        });\n                      });\n                    }\n                  }\n\n                  // Apply client-side sorting\n                  if (sortBy) {\n                    // Ensure we use client-side field name for sorting\n                    // If sortBy is a Salesforce field name, map it to client-side\n                    const clientSortField = mapSalesforceToClientField(sortBy);\n                    processedRecords = sortRecords(processedRecords, clientSortField, sortOrder);\n                    if (clientSortField !== sortBy) {\n                      console.log(`PM Approvals - Client-side sort applied: ${clientSortField} ${sortOrder} (mapped from ${sortBy})`);\n                    } else {\n                      console.log(`PM Approvals - Client-side sort applied: ${clientSortField} ${sortOrder}`);\n                    }\n                  }\n                  return processedRecords;\n                })(),\n                loading: loading,\n                onRowClick: record => console.log('Row clicked:', record),\n                onSort: handleSort,\n                sortBy: sortBy,\n                sortOrder: sortOrder,\n                selectedRows: selectedRows,\n                onRowSelect: handleRowSelect\n              }, void 0, false, {\n                fileName: _jsxFileName,\n                lineNumber: 869,\n                columnNumber: 17\n              }, this)\n            }, void 0, false, {\n              fileName: _jsxFileName,\n              lineNumber: 868,\n              columnNumber: 15\n            }, this)]\n          }, void 0, true, {\n            fileName: _jsxFileName,\n            lineNumber: 807,\n            columnNumber: 13\n          }, this)]\n        }, void 0, true, {\n          fileName: _jsxFileName,\n          lineNumber: 753,\n          columnNumber: 11\n        }, this)]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 711,\n        columnNumber: 9\n      }, this)\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 703,\n      columnNumber: 7\n    }, this), showApprovalModal && /*#__PURE__*/_jsxDEV(ApprovalModal, {\n      selectedCount: selectedRows.length,\n      onConfirm: handleApprovalConfirm,\n      onClose: () => setShowApprovalModal(false)\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 932,\n      columnNumber: 9\n    }, this), showRejectModal && /*#__PURE__*/_jsxDEV(RejectModal, {\n      selectedCount: selectedRows.length,\n      onConfirm: handleRejectConfirm,\n      onClose: () => setShowRejectModal(false)\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 939,\n      columnNumber: 9\n    }, this), showEmailModal && /*#__PURE__*/_jsxDEV(EmailModal, {\n      selectedCount: selectedRows.length,\n      onConfirm: handleEmailConfirm,\n      onClose: () => setShowEmailModal(false)\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 946,\n      columnNumber: 9\n    }, this)]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 700,\n    columnNumber: 5\n  }, this);\n};\n_s(PMApprovals, \"Uk8N7aQyOGsPLML9OxqoLHjy8y0=\", false, function () {\n  return [useAuth, useSidebarWidth];\n});\n_c = PMApprovals;\nexport default PMApprovals;\nvar _c;\n$RefreshReg$(_c, \"PMApprovals\");","map":{"version":3,"names":["React","useState","useEffect","useCallback","useRef","useAuth","Sidebar","useSidebarWidth","Menu","LogOut","RefreshCw","Loader","ChevronLeft","ChevronRight","apiClient","toast","BookmarkButton","DeadlinesPanel","RecordsCount","FieldFilter","PendingHoursCard","MetricsRow","PendingUnitsCard","ApprovalsTable","ActionButtons","ApprovalModal","RejectModal","EmailModal","jsxDEV","_jsxDEV","Fragment","_Fragment","mapSortFieldToSalesforce","clientFieldName","fieldMap","mapSalesforceToClientField","salesforceFieldName","reverseMap","sortRecords","records","sortField","sortOrder","Array","isArray","length","sorted","sort","a","b","aValue","bValue","aStr","String","trim","toLowerCase","bStr","numericFields","includes","aNum","parseFloat","bNum","aDate","Date","getTime","bDate","PMApprovals","_s","user","logout","sidebarOpen","setSidebarOpen","sidebarWidth","leftPanelCollapsed","setLeftPanelCollapsed","loading","setLoading","refreshing","setRefreshing","setRecords","summary","setSummary","deadlines","setDeadlines","filter","setFilter","field","value","sortBy","setSortBy","setSortOrder","offset","setOffset","hasMore","setHasMore","loadingMore","setLoadingMore","totalRecords","setTotalRecords","uniqueRecordsCount","setUniqueRecordsCount","duplicatesCount","setDuplicatesCount","selectedRows","setSelectedRows","showApprovalModal","setShowApprovalModal","showRejectModal","setShowRejectModal","showEmailModal","setShowEmailModal","warningShownRef","autoLoadingRef","recordsRef","recordsMapRef","Map","uniqueRecordsCountRef","totalDuplicatesRef","totalRecordsReceivedRef","tableContainerRef","recordsArray","current","newMap","forEach","record","id","set","fetchDeadlines","response","get","data","success","error","console","fetchSummary","silent","params","URLSearchParams","append","toString","warning","duration","icon","style","background","color","border","code","isBackendDown","fetchRecords","reset","startOffset","filterOverride","sortByOverride","sortOrderOverride","activeFilter","activeSortBy","activeSortOrder","currentOffset","salesforceSortBy","log","recordsData","newRecords","total","effectiveOffset","undefined","hasMoreData","recordsMap","uniqueRecords","duplicateCount","has","push","warn","calculatedDuplicates","stillHasMoreReset","setTimeout","catch","err","uniqueNewRecordsCount","prev","currentMap","uniqueNewRecords","updatedRecords","from","values","stillHasMore","initialLoadDoneRef","clientSortField","handleRefresh","e","preventDefault","stopPropagation","finally","handleApplyFilter","filterData","newSortBy","newSortOrder","needsRefetch","filters","activeFilters","f","handleClearFilter","handleSort","column","order","clientField","handleRowSelect","recordId","handleApprove","handleReject","handleSendEmail","handleApprovalConfirm","comment","post","transactionIds","approved","filtered","r","_error$response","_error$response$data","handleRejectConfirm","reason","rejected","_error$response2","_error$response2$data","handleEmailConfirm","emailData","info","className","children","isOpen","toggleSidebar","fileName","_jsxFileName","lineNumber","columnNumber","marginLeft","width","transition","onClick","size","disabled","title","email","charAt","toUpperCase","count","filteredCount","fieldValue","filterValue","duplicates","isLoadingMore","onApplyFilter","onClearFilter","currentSortBy","currentSortOrder","onSortChange","onApprove","onReject","onSendEmail","selectedCount","ref","calculatedSummary","filteredRecords","reduce","acc","selfReportedHours","systemTrackedHours","selfReportedUnits","totalPayment","totalPendingHours","totalHours","selfReportedTime","systemTracked","totalPendingUnits","displaySummary","payment","processedRecords","transactionId","contributorName","projectObjectiveName","projectName","accountName","transactionDate","allKeys","Object","keys","onRowClick","onSort","onRowSelect","onConfirm","onClose","_c","$RefreshReg$"],"sources":["/Users/mmoola/Documents/GitHub/project-tools/client/src/pages/ProjectManagement/PMApprovals/PMApprovals.js"],"sourcesContent":["import React, { useState, useEffect, useCallback, useRef } from 'react';\nimport { useAuth } from '../../../context/AuthContext';\nimport Sidebar from '../../../components/Sidebar';\nimport useSidebarWidth from '../../../hooks/useSidebarWidth';\nimport { Menu, LogOut, RefreshCw, Loader, ChevronLeft, ChevronRight } from 'lucide-react';\nimport apiClient from '../../../config/api';\nimport toast from 'react-hot-toast';\nimport BookmarkButton from '../../../components/BookmarkButton';\nimport DeadlinesPanel from './components/DeadlinesPanel';\nimport RecordsCount from './components/RecordsCount';\nimport FieldFilter from './components/FieldFilter';\nimport PendingHoursCard from './components/PendingHoursCard';\nimport MetricsRow from './components/MetricsRow';\nimport PendingUnitsCard from './components/PendingUnitsCard';\nimport ApprovalsTable from './components/ApprovalsTable';\nimport ActionButtons from './components/ActionButtons';\nimport ApprovalModal from './components/ApprovalModal';\nimport RejectModal from './components/RejectModal';\nimport EmailModal from './components/EmailModal';\nimport './PMApprovals.css';\nimport '../../../styles/Sidebar.css';\nimport '../../../styles/GlobalHeader.css';\n\n// Map client-side field names to Salesforce field names for sorting\nconst mapSortFieldToSalesforce = (clientFieldName) => {\n  const fieldMap = {\n    'transactionId': 'Transaction_ID__c',\n    'contributorName': 'Contact__r.Name',\n    'email': 'Contact__r.Email',\n    'projectName': 'Contributor_Project__r.Project_Objective__r.Project__r.Name',\n    'projectObjectiveName': 'Project_Objective__r.Name',\n    'accountName': 'Contributor_Project__r.Project_Objective__r.Project__r.Account__r.Name',\n    'transactionDate': 'Transaction_Date__c',\n    'variancePercent': 'Variance_Percent__c',\n    'payrate': 'Payrate__c',\n    'totalPayment': 'Total_Payment__c',\n    'status': 'Status__c'\n  };\n  return fieldMap[clientFieldName] || clientFieldName; // Return as-is if not in map (might already be Salesforce field name)\n};\n\n// Map Salesforce field names back to client-side field names\nconst mapSalesforceToClientField = (salesforceFieldName) => {\n  const reverseMap = {\n    'Transaction_ID__c': 'transactionId',\n    'Contact__r.Name': 'contributorName',\n    'Contact__r.Email': 'email',\n    'Contributor_Project__r.Project_Objective__r.Project__r.Name': 'projectName',\n    'Project_Objective__r.Name': 'projectObjectiveName',\n    'Contributor_Project__r.Project_Objective__r.Project__r.Account__r.Name': 'accountName',\n    'Transaction_Date__c': 'transactionDate',\n    'Variance_Percent__c': 'variancePercent',\n    'Payrate__c': 'payrate',\n    'Total_Payment__c': 'totalPayment',\n    'Status__c': 'status'\n  };\n  return reverseMap[salesforceFieldName] || salesforceFieldName; // Return as-is if not in map\n};\n\n// Client-side sorting function\nconst sortRecords = (records, sortField, sortOrder) => {\n  if (!sortField || !Array.isArray(records) || records.length === 0) {\n    return records;\n  }\n\n  const sorted = [...records].sort((a, b) => {\n    let aValue = a[sortField];\n    let bValue = b[sortField];\n\n    // Handle null/undefined values\n    if (aValue == null) aValue = '';\n    if (bValue == null) bValue = '';\n\n    // Convert to strings for comparison if not already\n    const aStr = String(aValue).trim().toLowerCase();\n    const bStr = String(bValue).trim().toLowerCase();\n\n    // Try to parse as numbers for numeric fields\n    const numericFields = ['variancePercent', 'payrate', 'totalPayment', 'selfReportedHours', 'selfReportedUnits', 'systemTrackedHours', 'systemTrackedUnits'];\n    if (numericFields.includes(sortField)) {\n      const aNum = parseFloat(aValue) || 0;\n      const bNum = parseFloat(bValue) || 0;\n      return sortOrder === 'ASC' ? aNum - bNum : bNum - aNum;\n    }\n\n    // Try to parse as dates for date fields\n    if (sortField === 'transactionDate') {\n      const aDate = aValue ? new Date(aValue).getTime() : 0;\n      const bDate = bValue ? new Date(bValue).getTime() : 0;\n      return sortOrder === 'ASC' ? aDate - bDate : bDate - aDate;\n    }\n\n    // String comparison\n    if (aStr < bStr) return sortOrder === 'ASC' ? -1 : 1;\n    if (aStr > bStr) return sortOrder === 'ASC' ? 1 : -1;\n    return 0;\n  });\n\n  return sorted;\n};\n\nconst PMApprovals = () => {\n  const { user, logout } = useAuth();\n  const [sidebarOpen, setSidebarOpen] = useState(true);\n  const sidebarWidth = useSidebarWidth(sidebarOpen);\n  const [leftPanelCollapsed, setLeftPanelCollapsed] = useState(false);\n  const [loading, setLoading] = useState(true);\n  const [refreshing, setRefreshing] = useState(false);\n  \n  // Data states\n  const [records, setRecords] = useState([]);\n  const [summary, setSummary] = useState(null);\n  const [deadlines, setDeadlines] = useState(null);\n  // Filter states - field-based filtering\n  const [filter, setFilter] = useState({ field: '', value: '' });\n  const [sortBy, setSortBy] = useState('transactionDate');\n  const [sortOrder, setSortOrder] = useState('DESC');\n  \n  // Table states\n  const [offset, setOffset] = useState(0);\n  const [hasMore, setHasMore] = useState(true);\n  const [loadingMore, setLoadingMore] = useState(false);\n  const [totalRecords, setTotalRecords] = useState(0);\n  const [uniqueRecordsCount, setUniqueRecordsCount] = useState(0);\n  const [duplicatesCount, setDuplicatesCount] = useState(0);\n  const [selectedRows, setSelectedRows] = useState([]);\n  \n  // Modal states\n  const [showApprovalModal, setShowApprovalModal] = useState(false);\n  const [showRejectModal, setShowRejectModal] = useState(false);\n  const [showEmailModal, setShowEmailModal] = useState(false);\n  \n  // Track if warning has been shown to avoid duplicates\n  const warningShownRef = useRef(false);\n  \n  // Track if auto-loading is in progress\n  const autoLoadingRef = useRef(false);\n  \n  // Track current records to avoid stale closures\n  const recordsRef = useRef([]);\n  \n  // Map-based record storage for O(1) lookup and guaranteed uniqueness\n  const recordsMapRef = useRef(new Map());\n  \n  // Track total unique records loaded (for display and comparison)\n  const uniqueRecordsCountRef = useRef(0);\n  \n  // Track total duplicates filtered out across all batches\n  const totalDuplicatesRef = useRef(0);\n  \n  // Track total records received from server (including duplicates)\n  const totalRecordsReceivedRef = useRef(0);\n  \n  const tableContainerRef = useRef(null);\n  \n  // Keep recordsRef and recordsMapRef in sync with records state\n  useEffect(() => {\n    // Ensure records is always an array\n    const recordsArray = Array.isArray(records) ? records : [];\n    recordsRef.current = recordsArray;\n    // Update map whenever records change\n    const newMap = new Map();\n    recordsArray.forEach(record => {\n      if (record && record.id) {\n        newMap.set(record.id, record);\n      }\n    });\n    recordsMapRef.current = newMap;\n  }, [records]);\n\n  // Fetch deadlines\n  const fetchDeadlines = useCallback(async () => {\n    try {\n      const response = await apiClient.get('/pm-approvals/deadlines');\n      if (response.data.success) {\n        setDeadlines(response.data.deadlines);\n      }\n    } catch (error) {\n      console.error('Error fetching deadlines:', error);\n    }\n  }, []);\n\n  // Fetch filter options\n  // No longer need to fetch filter options - values come from table data\n\n  // Fetch summary metrics\n  const fetchSummary = useCallback(async (silent = false) => {\n    try {\n      const params = new URLSearchParams();\n      // For summary, use the filter if available (server-side filters only)\n      if (filter && filter.field && filter.value && !['accountName', 'projectName'].includes(filter.field)) {\n        params.append('filterField', filter.field);\n        params.append('filterValue', filter.value);\n      }\n      \n      const response = await apiClient.get(`/pm-approvals/summary?${params.toString()}`);\n      if (response.data.success) {\n        setSummary(response.data.data);\n        \n        if (response.data.warning && !silent && !warningShownRef.current) {\n          warningShownRef.current = true;\n          toast(response.data.warning, {\n            duration: 8000,\n            icon: 'âš ï¸',\n            style: {\n              background: '#fffbeb',\n              color: '#92400e',\n              border: '1px solid #fde68a'\n            }\n          });\n        }\n      }\n    } catch (error) {\n      console.error('Error fetching summary:', error);\n      if (!silent && error.code !== 'ECONNREFUSED' && error.code !== 'ERR_NETWORK' && !error.isBackendDown) {\n        toast.error('Failed to load summary metrics');\n      }\n    }\n  }, [filter]);\n\n  // Simplified fetch records function - loads 5000 records per batch\n  const fetchRecords = useCallback(async (reset = false, startOffset = null, filterOverride = null, sortByOverride = null, sortOrderOverride = null) => {\n    // Prevent concurrent fetches\n    if (autoLoadingRef.current && !reset) {\n      return;\n    }\n    \n    autoLoadingRef.current = true;\n    \n    // Use filterOverride if provided, otherwise use current filter state\n    const activeFilter = filterOverride !== null ? filterOverride : filter;\n    // Use sort overrides if provided, otherwise use current sort state\n    const activeSortBy = sortByOverride !== null ? sortByOverride : sortBy;\n    const activeSortOrder = sortOrderOverride !== null ? sortOrderOverride : sortOrder;\n    \n    if (reset) {\n      setLoading(true);\n      setRecords([]);\n      recordsRef.current = [];\n      recordsMapRef.current = new Map(); // Reset map\n      uniqueRecordsCountRef.current = 0; // Reset unique count\n      totalDuplicatesRef.current = 0; // Reset duplicates count\n      totalRecordsReceivedRef.current = 0; // Reset total received\n      setOffset(0);\n      setTotalRecords(0);\n      setUniqueRecordsCount(0);\n      setDuplicatesCount(0);\n      setHasMore(true);\n      autoLoadingRef.current = false; // Allow reset to proceed\n    } else {\n      setLoadingMore(true);\n    }\n\n    try {\n      const currentOffset = startOffset !== null ? startOffset : offset;\n      const params = new URLSearchParams();\n      params.append('offset', currentOffset.toString());\n      params.append('limit', '5000'); // Request 5,000 records per batch\n      // Map client-side field name to Salesforce field name for server query\n      const salesforceSortBy = mapSortFieldToSalesforce(activeSortBy) || 'Transaction_Date__c';\n      params.append('sortBy', salesforceSortBy);\n      params.append('sortOrder', activeSortOrder);\n      \n      // Add field-based filter parameters\n      if (activeFilter && activeFilter.field && activeFilter.value) {\n        params.append('filterField', activeFilter.field);\n        params.append('filterValue', activeFilter.value);\n      }\n      \n      console.log('PM Approvals - Fetching records with filter:', activeFilter);\n      console.log('PM Approvals - Query params:', params.toString());\n      \n      const response = await apiClient.get(`/pm-approvals/list?${params.toString()}`);\n      \n      if (response.data.success) {\n        // Ensure records is an array\n        const recordsData = response.data.records;\n        const newRecords = Array.isArray(recordsData) ? recordsData : [];\n        const total = response.data.total || 0;\n        const effectiveOffset = response.data.effectiveOffset !== undefined \n          ? response.data.effectiveOffset \n          : (currentOffset + newRecords.length);\n        const hasMoreData = response.data.hasMore || false;\n        \n        setTotalRecords(total);\n        \n        // SYSTEMATIC DEDUPLICATION: Use Map-based approach for guaranteed uniqueness\n        if (reset) {\n          // Reset: Build new map from scratch\n          const recordsMap = new Map();\n          const uniqueRecords = [];\n          let duplicateCount = 0;\n          \n          newRecords.forEach(record => {\n            if (record && record.id) {\n              // Only add if not already in map (guarantees uniqueness)\n              if (!recordsMap.has(record.id)) {\n                recordsMap.set(record.id, record);\n                uniqueRecords.push(record);\n              } else {\n                duplicateCount++;\n                console.warn(`Duplicate record detected during reset: ${record.id}`);\n              }\n            }\n          });\n          \n          recordsMapRef.current = recordsMap;\n          setRecords(uniqueRecords);\n          recordsRef.current = uniqueRecords;\n          uniqueRecordsCountRef.current = uniqueRecords.length;\n          totalRecordsReceivedRef.current = newRecords.length;\n          \n          // Calculate duplicates consistently: total received - unique count\n          // This ensures the count is always accurate regardless of batch order\n          const calculatedDuplicates = totalRecordsReceivedRef.current - uniqueRecordsCountRef.current;\n          totalDuplicatesRef.current = calculatedDuplicates;\n          \n          setUniqueRecordsCount(uniqueRecords.length);\n          setDuplicatesCount(calculatedDuplicates);\n          setOffset(uniqueRecords.length);\n          \n          if (newRecords.length !== uniqueRecords.length) {\n            console.warn(`Deduplication: ${newRecords.length} records received, ${uniqueRecords.length} unique records after deduplication, ${calculatedDuplicates} duplicates filtered`);\n          }\n          \n          // Check if we have more records to load (for reset case)\n          // Continue loading as long as server says hasMore=true, regardless of unique count\n          // This ensures we process all batches to find all unique records\n          const stillHasMoreReset = hasMoreData && (newRecords.length > 0);\n          setHasMore(stillHasMoreReset);\n          \n          console.log(`Batch loaded (reset): offset=0, received=${newRecords.length}, unique=${uniqueRecords.length}, totalUnique=${uniqueRecordsCountRef.current}, serverTotal=${total}, hasMore=${stillHasMoreReset}`);\n          \n          // Auto-load next batch if server indicates more records available\n          // We continue loading even if all records in this batch were duplicates,\n          // because there might be more unique records in subsequent batches\n          if (stillHasMoreReset) {\n            setTimeout(() => {\n              fetchRecords(false, effectiveOffset).catch((err) => {\n                console.error('Error auto-loading next batch:', err);\n                setHasMore(false);\n              });\n            }, 50); // Small delay to keep UI responsive\n          } else {\n            if (newRecords.length === 0) {\n              console.log('Stopping auto-load (reset): No records received from API');\n            } else {\n              console.log(`All records loaded (reset): Loaded ${uniqueRecordsCountRef.current} unique records from ${total} total records`);\n            }\n            setHasMore(false);\n          }\n        } else {\n          // Append: Use functional update with Map-based deduplication\n          let uniqueNewRecordsCount = 0;\n          setRecords(prev => {\n            // Get current map for O(1) lookup\n            const currentMap = recordsMapRef.current;\n            const uniqueNewRecords = [];\n            let duplicateCount = 0;\n            \n            newRecords.forEach(record => {\n              if (record && record.id) {\n                if (!currentMap.has(record.id)) {\n                  // New record - add to map and list\n                  currentMap.set(record.id, record);\n                  uniqueNewRecords.push(record);\n                } else {\n                  // Duplicate detected\n                  duplicateCount++;\n                  console.warn(`Duplicate record detected during append: ${record.id}`);\n                }\n              }\n            });\n            \n            // Track how many unique records were actually added\n            uniqueNewRecordsCount = uniqueNewRecords.length;\n            \n            // Update total duplicates and total received\n            totalDuplicatesRef.current += duplicateCount;\n            totalRecordsReceivedRef.current += newRecords.length;\n            \n            if (duplicateCount > 0) {\n              console.warn(`Deduplication: ${duplicateCount} duplicate(s) filtered out from ${newRecords.length} new records`);\n            }\n            \n            // Build new array from map values to ensure no duplicates\n            const updatedRecords = Array.from(currentMap.values());\n            recordsMapRef.current = currentMap;\n            recordsRef.current = updatedRecords;\n            uniqueRecordsCountRef.current = updatedRecords.length; // Update unique count\n            \n            // Calculate duplicates consistently: total received - unique count\n            // This ensures the count is always accurate regardless of batch order\n            const calculatedDuplicates = totalRecordsReceivedRef.current - uniqueRecordsCountRef.current;\n            \n            // Update state for display - use calculated duplicates for consistency\n            setUniqueRecordsCount(updatedRecords.length);\n            setDuplicatesCount(calculatedDuplicates);\n            \n            // Also update the ref to keep it in sync\n            totalDuplicatesRef.current = calculatedDuplicates;\n            \n            return updatedRecords;\n          });\n          setOffset(effectiveOffset);\n          \n          // Check if we have more records to load\n          // IMPORTANT: Continue loading as long as server says hasMore=true\n          // This ensures we process all batches to find all unique records, even if\n          // some batches contain only duplicates\n          // Only stop if:\n          // 1. Server says hasMore=false (no more batches)\n          // 2. We received 0 records from API (end of data)\n          const stillHasMore = hasMoreData && (newRecords.length > 0);\n          setHasMore(stillHasMore);\n          \n          console.log(`Batch loaded: offset=${currentOffset}, received=${newRecords.length}, unique=${uniqueNewRecordsCount}, totalUnique=${uniqueRecordsCountRef.current}, effectiveOffset=${effectiveOffset}, serverTotal=${total}, hasMore=${stillHasMore}`);\n          \n          // Auto-load next batch if server indicates more records available\n          // Continue loading even if all records in this batch were duplicates,\n          // because there might be more unique records in subsequent batches\n          if (stillHasMore) {\n            setTimeout(() => {\n              fetchRecords(false, effectiveOffset).catch((err) => {\n                console.error('Error auto-loading next batch:', err);\n                setHasMore(false);\n              });\n            }, 50); // Small delay to keep UI responsive\n          } else {\n            if (newRecords.length === 0) {\n              console.log('Stopping auto-load: No records received from API');\n            } else {\n              console.log(`All records loaded: Loaded ${uniqueRecordsCountRef.current} unique records from ${total} total records`);\n            }\n            setHasMore(false);\n          }\n        }\n        \n        if (response.data.warning && reset && !warningShownRef.current) {\n          warningShownRef.current = true;\n          toast(response.data.warning, {\n            duration: 8000,\n            icon: 'âš ï¸',\n            style: {\n              background: '#fffbeb',\n              color: '#92400e',\n              border: '1px solid #fde68a'\n            }\n          });\n        }\n      } else {\n        toast.error(response.data.error || 'Failed to fetch approvals');\n        setHasMore(false);\n      }\n    } catch (error) {\n      console.error('Error fetching records:', error);\n      if (error.code !== 'ECONNREFUSED' && error.code !== 'ERR_NETWORK' && !error.isBackendDown) {\n        toast.error('Failed to fetch approvals');\n      }\n      setHasMore(false);\n    } finally {\n      setLoading(false);\n      setLoadingMore(false);\n      setRefreshing(false);\n      autoLoadingRef.current = false;\n    }\n  }, [filter, sortBy, sortOrder, offset]);\n\n  // Track if initial load has been done\n  const initialLoadDoneRef = useRef(false);\n  \n  // Initial load - only runs once on mount\n  useEffect(() => {\n    if (!initialLoadDoneRef.current) {\n      initialLoadDoneRef.current = true;\n      fetchDeadlines();\n      fetchSummary(true);\n      fetchRecords(true);\n    }\n  }, [fetchDeadlines, fetchSummary, fetchRecords]);\n\n  // Normalize sortBy to always use client-side field names (only if it's a Salesforce field name)\n  useEffect(() => {\n    const clientSortField = mapSalesforceToClientField(sortBy);\n    // Only update if it's actually a Salesforce field name (mapping changed it)\n    // This prevents infinite loops since if it's already a client-side name, clientSortField === sortBy\n    if (clientSortField !== sortBy && sortBy) {\n      console.log(`Normalizing sortBy from Salesforce field \"${sortBy}\" to client-side field \"${clientSortField}\"`);\n      setSortBy(clientSortField);\n    }\n  }, [sortBy]);\n\n  // Note: Filters and sort changes no longer trigger data reset\n  // Data persists during the session and only reloads when refresh button is clicked\n\n  const handleRefresh = useCallback((e) => {\n    if (e) {\n      e.preventDefault();\n      e.stopPropagation();\n    }\n    setRefreshing(true);\n    setOffset(0);\n    setRecords([]);\n    recordsRef.current = [];\n    setHasMore(true);\n    setSelectedRows([]);\n    setTotalRecords(0);\n    warningShownRef.current = false;\n    autoLoadingRef.current = false;\n    fetchRecords(true).finally(() => {\n      setRefreshing(false);\n    });\n    fetchSummary();\n  }, [fetchRecords, fetchSummary]);\n\n\n  const handleApplyFilter = useCallback((filterData) => {\n    // Handle new structure from FieldFilter: { filters: [...], sortBy: '', sortOrder: '' }\n    // or old structure: { field: '', value: '' }\n    let activeFilter = null;\n    let newSortBy = sortBy;\n    let newSortOrder = sortOrder;\n    let needsRefetch = false;\n\n    // Check if it's the new structure (from FieldFilter)\n    if (filterData.filters !== undefined) {\n      // New structure: { filters: [...], sortBy: '', sortOrder: '' }\n      const activeFilters = filterData.filters.filter(f => f.field && f.value);\n      if (activeFilters.length > 0) {\n        // Use the first filter for now (supporting single filter)\n        activeFilter = activeFilters[0];\n      }\n      \n      // Update sort if provided\n      if (filterData.sortBy !== undefined) {\n        // Map client-side field name to Salesforce field name\n        const clientSortField = filterData.sortBy || 'transactionDate';\n        newSortBy = mapSortFieldToSalesforce(clientSortField) || 'Transaction_Date__c';\n        needsRefetch = true;\n      }\n      if (filterData.sortOrder !== undefined) {\n        newSortOrder = filterData.sortOrder || 'DESC';\n        needsRefetch = true;\n      }\n    } else {\n      // Old structure: { field: '', value: '' }\n      activeFilter = filterData;\n    }\n\n    // Update sort state if changed\n    if (newSortBy !== sortBy || newSortOrder !== sortOrder) {\n      setSortBy(newSortBy);\n      setSortOrder(newSortOrder);\n      // No need to refetch - sorting is now client-side\n    }\n\n    // ALL filtering is now client-side - just update the filter state\n    if (activeFilter) {\n      setFilter(activeFilter);\n      setSelectedRows([]);\n      console.log('PM Approvals - Applying client-side filter:', activeFilter);\n    } else if (needsRefetch && !activeFilter) {\n      // Only sort changed, no filter - just update sort state (already done above)\n      setSelectedRows([]);\n      console.log('PM Approvals - Applying client-side sort:', { sortBy: newSortBy, sortOrder: newSortOrder });\n    }\n  }, [fetchRecords, fetchSummary, sortBy, sortOrder]);\n\n  const handleClearFilter = useCallback(() => {\n    // All filtering is client-side - just clear the filter and sort state\n    setFilter({ field: '', value: '' });\n    setSortBy('transactionDate');\n    setSortOrder('DESC');\n    setSelectedRows([]);\n    \n    console.log('PM Approvals - Clearing client-side filter and sort');\n    // No server refetch needed - filtering and sorting are client-side\n  }, []);\n\n  const handleSort = useCallback((column, order) => {\n    // Use client-side field name directly for client-side sorting\n    const clientField = column || 'transactionDate';\n    const newSortBy = clientField;\n    const newSortOrder = order || 'DESC';\n    \n    setSortBy(newSortBy);\n    setSortOrder(newSortOrder);\n    setSelectedRows([]);\n    \n    console.log('PM Approvals - Applying client-side sort:', { field: newSortBy, order: newSortOrder });\n    // No server refetch needed - sorting is now client-side\n  }, []);\n\n  const handleRowSelect = (recordId) => {\n    setSelectedRows(prev => {\n      if (prev.includes(recordId)) {\n        return prev.filter(id => id !== recordId);\n      } else {\n        return [...prev, recordId];\n      }\n    });\n  };\n\n  const handleApprove = () => {\n    if (selectedRows.length === 0) {\n      toast.error('Please select at least one record to approve');\n      return;\n    }\n    setShowApprovalModal(true);\n  };\n\n  const handleReject = () => {\n    if (selectedRows.length === 0) {\n      toast.error('Please select at least one record to reject');\n      return;\n    }\n    setShowRejectModal(true);\n  };\n\n  const handleSendEmail = () => {\n    if (selectedRows.length === 0) {\n      toast.error('Please select at least one record to email');\n      return;\n    }\n    setShowEmailModal(true);\n  };\n\n  const handleApprovalConfirm = async (comment) => {\n    try {\n      const response = await apiClient.post('/pm-approvals/approve', {\n        transactionIds: selectedRows,\n        comment: comment || ''\n      });\n      \n      if (response.data.success) {\n        toast.success(`Successfully approved ${response.data.approved} record(s)`);\n        setRecords(prev => {\n          const filtered = prev.filter(r => !selectedRows.includes(r.id));\n          // Update map to match filtered records\n          const newMap = new Map();\n          filtered.forEach(record => {\n            if (record && record.id) {\n              newMap.set(record.id, record);\n            }\n          });\n          recordsMapRef.current = newMap;\n          recordsRef.current = filtered;\n          return filtered;\n        });\n        setSelectedRows([]);\n        setShowApprovalModal(false);\n        fetchSummary();\n      } else {\n        toast.error(response.data.error || 'Failed to approve records');\n      }\n    } catch (error) {\n      toast.error(error.response?.data?.error || 'Failed to approve records');\n    }\n  };\n\n  const handleRejectConfirm = async (reason) => {\n    try {\n      const response = await apiClient.post('/pm-approvals/reject', {\n        transactionIds: selectedRows,\n        reason: reason || ''\n      });\n      \n      if (response.data.success) {\n        toast.success(`Successfully rejected ${response.data.rejected} record(s)`);\n        setRecords(prev => {\n          const filtered = prev.filter(r => !selectedRows.includes(r.id));\n          // Update map to match filtered records\n          const newMap = new Map();\n          filtered.forEach(record => {\n            if (record && record.id) {\n              newMap.set(record.id, record);\n            }\n          });\n          recordsMapRef.current = newMap;\n          recordsRef.current = filtered;\n          return filtered;\n        });\n        setSelectedRows([]);\n        setShowRejectModal(false);\n        fetchSummary();\n      } else {\n        toast.error(response.data.error || 'Failed to reject records');\n      }\n    } catch (error) {\n      toast.error(error.response?.data?.error || 'Failed to reject records');\n    }\n  };\n\n  const handleEmailConfirm = async (emailData) => {\n    toast.info('Email functionality coming soon');\n    setShowEmailModal(false);\n  };\n\n  return (\n    <div className=\"dashboard-layout\">\n      <Sidebar isOpen={sidebarOpen} toggleSidebar={() => setSidebarOpen(!sidebarOpen)} />\n      \n      <div \n        className=\"pm-approvals-page\" \n        style={{ \n          marginLeft: `${sidebarWidth}px`, \n          width: `calc(100% - ${sidebarWidth}px)`,\n          transition: 'margin-left 0.2s ease, width 0.2s ease'\n        }}\n      >\n        <div className=\"pm-approvals-container\">\n          {/* Header */}\n          <div className=\"pm-approvals-header\">\n            <div className=\"header-content\">\n              <div className=\"header-left\">\n                <button \n                  className=\"header-menu-toggle\"\n                  onClick={() => setSidebarOpen(!sidebarOpen)}\n                  aria-label=\"Toggle sidebar\"\n                >\n                  <Menu size={20} />\n                </button>\n                <div>\n                  <h1 className=\"page-title\">PM Approvals for Self Reported Time</h1>\n                </div>\n              </div>\n              <div className=\"header-right\">\n                <BookmarkButton />\n                <button\n                  className=\"refresh-btn\"\n                  onClick={handleRefresh}\n                  disabled={refreshing}\n                  title=\"Refresh\"\n                >\n                  <RefreshCw size={18} className={refreshing ? 'spinning' : ''} />\n                </button>\n                <div className=\"header-user-profile\">\n                  <div className=\"user-profile\">\n                    <div className=\"user-avatar\">\n                      {(user?.email || 'U').charAt(0).toUpperCase()}\n                    </div>\n                    <span className=\"user-name\">{user?.email || 'User'}</span>\n                    <button className=\"logout-btn\" onClick={logout} title=\"Logout\">\n                      <LogOut size={18} />\n                    </button>\n                  </div>\n                </div>\n              </div>\n            </div>\n          </div>\n\n          {/* Main Content */}\n          <div className=\"pm-approvals-content\">\n            {/* Left Sidebar */}\n            <div className={`pm-approvals-sidebar ${leftPanelCollapsed ? 'collapsed' : ''}`}>\n              <button\n                className=\"left-panel-toggle\"\n                onClick={() => setLeftPanelCollapsed(!leftPanelCollapsed)}\n                aria-label={leftPanelCollapsed ? 'Expand left panel' : 'Collapse left panel'}\n                title={leftPanelCollapsed ? 'Expand left panel' : 'Collapse left panel'}\n              >\n                {leftPanelCollapsed ? <ChevronRight size={18} /> : <ChevronLeft size={18} />}\n              </button>\n              {!leftPanelCollapsed && (\n                <>\n                  <DeadlinesPanel deadlines={deadlines} loading={!deadlines} />\n                  <RecordsCount \n                count={(() => {\n                  // If client-side filtering is active, show filtered count (works for all fields now)\n                  if (filter.field && filter.value) {\n                    const filteredCount = records.filter(record => {\n                      if (!record) return false;\n                      const fieldValue = String(record[filter.field] || '').trim();\n                      const filterValue = String(filter.value || '').trim();\n                      return fieldValue === filterValue;\n                    }).length;\n                    return filteredCount;\n                  }\n                  return uniqueRecordsCount > 0 ? uniqueRecordsCount : records.length;\n                })()}\n                total={uniqueRecordsCount > 0 ? uniqueRecordsCount : records.length}\n                duplicates={duplicatesCount || 0}\n                loading={loading} \n                isLoadingMore={loadingMore || hasMore}\n              />\n              <FieldFilter\n                records={records}\n                onApplyFilter={handleApplyFilter}\n                onClearFilter={handleClearFilter}\n                loading={loading}\n                currentSortBy={sortBy}\n                currentSortOrder={sortOrder}\n                onSortChange={handleSort}\n              />\n                  <ActionButtons\n                    onApprove={handleApprove}\n                    onReject={handleReject}\n                    onSendEmail={handleSendEmail}\n                    disabled={loading}\n                    selectedCount={selectedRows.length}\n                  />\n                </>\n              )}\n            </div>\n\n            {/* Main Content Area */}\n            <div className=\"pm-approvals-main\" ref={tableContainerRef}>\n              {/* Summary Metrics */}\n              <div className=\"summary-metrics-section\">\n                {(() => {\n                  // Calculate summary from filtered records if filter is applied\n                  let calculatedSummary = null;\n                  if (filter.field && filter.value) {\n                    const filteredRecords = Array.isArray(records) ? records.filter(record => {\n                      if (!record) return false;\n                      const fieldValue = String(record[filter.field] || '').trim();\n                      const filterValue = String(filter.value || '').trim();\n                      return fieldValue === filterValue;\n                    }) : [];\n                    \n                    calculatedSummary = filteredRecords.reduce((acc, record) => {\n                      const selfReportedHours = parseFloat(record.selfReportedHours) || 0;\n                      const systemTrackedHours = parseFloat(record.systemTrackedHours) || 0;\n                      const selfReportedUnits = parseFloat(record.selfReportedUnits) || 0;\n                      const totalPayment = parseFloat(record.totalPayment) || 0;\n                      \n                      acc.totalPendingHours += selfReportedHours;\n                      acc.totalHours += systemTrackedHours;\n                      acc.selfReportedTime += selfReportedHours;\n                      acc.systemTracked += systemTrackedHours;\n                      acc.totalPayment += totalPayment;\n                      acc.totalPendingUnits += selfReportedUnits;\n                      \n                      return acc;\n                    }, {\n                      totalPendingHours: 0,\n                      totalHours: 0,\n                      selfReportedTime: 0,\n                      systemTracked: 0,\n                      totalPayment: 0,\n                      totalPendingUnits: 0\n                    });\n                  }\n                  \n                  // Use calculated summary if filter is applied, otherwise use server summary\n                  const displaySummary = calculatedSummary || summary || {};\n                  \n                  return (\n                    <>\n                      <PendingHoursCard\n                        totalPendingHours={displaySummary.totalPendingHours || 0}\n                        totalHours={displaySummary.totalHours || 0}\n                      />\n                      <MetricsRow\n                        selfReportedTime={displaySummary.selfReportedTime || 0}\n                        systemTracked={displaySummary.systemTracked || 0}\n                        payment={displaySummary.totalPayment || 0}\n                      />\n                      <PendingUnitsCard\n                        totalPendingUnits={displaySummary.totalPendingUnits || 0}\n                      />\n                    </>\n                  );\n                })()}\n              </div>\n\n              {/* Table */}\n              <div className=\"approvals-table-section\">\n                <ApprovalsTable\n                  records={(() => {\n                    // Apply client-side filtering and sorting for all fields\n                    let processedRecords = Array.isArray(records) ? records : [];\n                    \n                    // Apply filtering for all fields\n                    if (filter.field && filter.value) {\n                      processedRecords = processedRecords.filter(record => {\n                        if (!record) return false;\n                        const fieldValue = String(record[filter.field] || '').trim();\n                        const filterValue = String(filter.value || '').trim();\n                        return fieldValue === filterValue;\n                      });\n                      console.log(`PM Approvals - Client-side filter applied: ${filter.field} = \"${filter.value}\", ${processedRecords.length} records match`);\n                      \n                      // Debug logging for specific transaction IDs\n                      if (filter.field === 'transactionId' && ['123028', '123029', '123030', '123031'].includes(filter.value)) {\n                        processedRecords.forEach(record => {\n                          console.log(`ðŸ” CLIENT DEBUG - Record for Transaction ID ${filter.value}:`, {\n                            transactionId: record.transactionId,\n                            contributorName: record.contributorName || '(empty)',\n                            email: record.email || '(empty)',\n                            projectObjectiveName: record.projectObjectiveName || '(empty)',\n                            projectName: record.projectName || '(empty)',\n                            accountName: record.accountName || '(empty)',\n                            transactionDate: record.transactionDate,\n                            allKeys: Object.keys(record)\n                          });\n                        });\n                      }\n                    }\n                    \n                    // Apply client-side sorting\n                    if (sortBy) {\n                      // Ensure we use client-side field name for sorting\n                      // If sortBy is a Salesforce field name, map it to client-side\n                      const clientSortField = mapSalesforceToClientField(sortBy);\n                      processedRecords = sortRecords(processedRecords, clientSortField, sortOrder);\n                      if (clientSortField !== sortBy) {\n                        console.log(`PM Approvals - Client-side sort applied: ${clientSortField} ${sortOrder} (mapped from ${sortBy})`);\n                      } else {\n                        console.log(`PM Approvals - Client-side sort applied: ${clientSortField} ${sortOrder}`);\n                      }\n                    }\n                    \n                    return processedRecords;\n                  })()}\n                  loading={loading}\n                  onRowClick={(record) => console.log('Row clicked:', record)}\n                  onSort={handleSort}\n                  sortBy={sortBy}\n                  sortOrder={sortOrder}\n                  selectedRows={selectedRows}\n                  onRowSelect={handleRowSelect}\n                />\n              </div>\n            </div>\n          </div>\n        </div>\n      </div>\n\n      {/* Modals */}\n      {showApprovalModal && (\n        <ApprovalModal\n          selectedCount={selectedRows.length}\n          onConfirm={handleApprovalConfirm}\n          onClose={() => setShowApprovalModal(false)}\n        />\n      )}\n      {showRejectModal && (\n        <RejectModal\n          selectedCount={selectedRows.length}\n          onConfirm={handleRejectConfirm}\n          onClose={() => setShowRejectModal(false)}\n        />\n      )}\n      {showEmailModal && (\n        <EmailModal\n          selectedCount={selectedRows.length}\n          onConfirm={handleEmailConfirm}\n          onClose={() => setShowEmailModal(false)}\n        />\n      )}\n    </div>\n  );\n};\n\nexport default PMApprovals;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}