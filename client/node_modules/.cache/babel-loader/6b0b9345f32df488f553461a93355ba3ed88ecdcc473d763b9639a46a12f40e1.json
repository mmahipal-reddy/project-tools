{"ast":null,"code":"/**\n * Client Tool Account Conflict Detection\n * Detects duplicate mappings and conflicts\n *//**\n * Detects duplicate account mappings across projects\n * @param {Array} projects - Array of projects with account assignments\n * @param {Object} selectedAccounts - Object mapping projectId to accountId\n * @returns {Array} - Array of conflict objects { accountId, projectIds: Array<string>, type: 'duplicate' }\n */export const detectDuplicateMappings=(projects,selectedAccounts)=>{const conflicts=[];const accountToProjectsMap=new Map();// Build map of accountId -> array of projectIds\nObject.entries(selectedAccounts).forEach(_ref=>{let[projectId,accountId]=_ref;if(accountId){if(!accountToProjectsMap.has(accountId)){accountToProjectsMap.set(accountId,[]);}accountToProjectsMap.get(accountId).push(projectId);}});// Find accounts mapped to multiple projects\naccountToProjectsMap.forEach((projectIds,accountId)=>{if(projectIds.length>1){const projectNames=projectIds.map(pid=>{const project=projects.find(p=>p.id===pid);return project?project.name:pid;}).filter(Boolean);conflicts.push({accountId,projectIds,projectNames,type:'duplicate',message:\"Account is mapped to \".concat(projectIds.length,\" projects: \").concat(projectNames.join(', '))});}});return conflicts;};/**\n * Detects if an account is already mapped to a different project\n * @param {string} accountId - The account ID to check\n * @param {string} currentProjectId - The current project ID\n * @param {Array} projects - Array of all projects\n * @returns {Object|null} - Conflict object or null\n */export const detectExistingMapping=(accountId,currentProjectId,projects)=>{if(!accountId)return null;const existingProject=projects.find(p=>p.id!==currentProjectId&&p.clientToolAccountUsed===accountId);if(existingProject){return{accountId,existingProjectId:existingProject.id,existingProjectName:existingProject.name,currentProjectId,type:'existing_mapping',message:\"This account is already mapped to project: \".concat(existingProject.name)};}return null;};/**\n * Gets all conflicts for a set of assignments\n * @param {Array} projects - Array of projects\n * @param {Object} selectedAccounts - Object mapping projectId to accountId\n * @returns {Array} - Array of all conflict objects\n */export const getAllConflicts=(projects,selectedAccounts)=>{const conflicts=[];// Check for duplicate mappings\nconst duplicateConflicts=detectDuplicateMappings(projects,selectedAccounts);conflicts.push(...duplicateConflicts);// Check for existing mappings\nObject.entries(selectedAccounts).forEach(_ref2=>{let[projectId,accountId]=_ref2;if(accountId){const existingMapping=detectExistingMapping(accountId,projectId,projects);if(existingMapping){conflicts.push(existingMapping);}}});return conflicts;};","map":{"version":3,"names":["detectDuplicateMappings","projects","selectedAccounts","conflicts","accountToProjectsMap","Map","Object","entries","forEach","_ref","projectId","accountId","has","set","get","push","projectIds","length","projectNames","map","pid","project","find","p","id","name","filter","Boolean","type","message","concat","join","detectExistingMapping","currentProjectId","existingProject","clientToolAccountUsed","existingProjectId","existingProjectName","getAllConflicts","duplicateConflicts","_ref2","existingMapping"],"sources":["/Users/mmoola/Documents/GitHub/project-tools/client/src/utils/clientToolAccountConflictDetection.js"],"sourcesContent":["/**\n * Client Tool Account Conflict Detection\n * Detects duplicate mappings and conflicts\n */\n\n/**\n * Detects duplicate account mappings across projects\n * @param {Array} projects - Array of projects with account assignments\n * @param {Object} selectedAccounts - Object mapping projectId to accountId\n * @returns {Array} - Array of conflict objects { accountId, projectIds: Array<string>, type: 'duplicate' }\n */\nexport const detectDuplicateMappings = (projects, selectedAccounts) => {\n  const conflicts = [];\n  const accountToProjectsMap = new Map();\n\n  // Build map of accountId -> array of projectIds\n  Object.entries(selectedAccounts).forEach(([projectId, accountId]) => {\n    if (accountId) {\n      if (!accountToProjectsMap.has(accountId)) {\n        accountToProjectsMap.set(accountId, []);\n      }\n      accountToProjectsMap.get(accountId).push(projectId);\n    }\n  });\n\n  // Find accounts mapped to multiple projects\n  accountToProjectsMap.forEach((projectIds, accountId) => {\n    if (projectIds.length > 1) {\n      const projectNames = projectIds\n        .map(pid => {\n          const project = projects.find(p => p.id === pid);\n          return project ? project.name : pid;\n        })\n        .filter(Boolean);\n\n      conflicts.push({\n        accountId,\n        projectIds,\n        projectNames,\n        type: 'duplicate',\n        message: `Account is mapped to ${projectIds.length} projects: ${projectNames.join(', ')}`\n      });\n    }\n  });\n\n  return conflicts;\n};\n\n/**\n * Detects if an account is already mapped to a different project\n * @param {string} accountId - The account ID to check\n * @param {string} currentProjectId - The current project ID\n * @param {Array} projects - Array of all projects\n * @returns {Object|null} - Conflict object or null\n */\nexport const detectExistingMapping = (accountId, currentProjectId, projects) => {\n  if (!accountId) return null;\n\n  const existingProject = projects.find(\n    p => p.id !== currentProjectId && p.clientToolAccountUsed === accountId\n  );\n\n  if (existingProject) {\n    return {\n      accountId,\n      existingProjectId: existingProject.id,\n      existingProjectName: existingProject.name,\n      currentProjectId,\n      type: 'existing_mapping',\n      message: `This account is already mapped to project: ${existingProject.name}`\n    };\n  }\n\n  return null;\n};\n\n/**\n * Gets all conflicts for a set of assignments\n * @param {Array} projects - Array of projects\n * @param {Object} selectedAccounts - Object mapping projectId to accountId\n * @returns {Array} - Array of all conflict objects\n */\nexport const getAllConflicts = (projects, selectedAccounts) => {\n  const conflicts = [];\n\n  // Check for duplicate mappings\n  const duplicateConflicts = detectDuplicateMappings(projects, selectedAccounts);\n  conflicts.push(...duplicateConflicts);\n\n  // Check for existing mappings\n  Object.entries(selectedAccounts).forEach(([projectId, accountId]) => {\n    if (accountId) {\n      const existingMapping = detectExistingMapping(accountId, projectId, projects);\n      if (existingMapping) {\n        conflicts.push(existingMapping);\n      }\n    }\n  });\n\n  return conflicts;\n};\n\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}