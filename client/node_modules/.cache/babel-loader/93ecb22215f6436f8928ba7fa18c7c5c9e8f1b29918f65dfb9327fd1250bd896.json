{"ast":null,"code":"/**\n * Client Tool Account Conflict Detection\n * Detects duplicate mappings and conflicts\n */\n\n/**\n * Detects duplicate account mappings across projects\n * @param {Array} projects - Array of projects with account assignments\n * @param {Object} selectedAccounts - Object mapping projectId to accountId\n * @returns {Array} - Array of conflict objects { accountId, projectIds: Array<string>, type: 'duplicate' }\n */\nexport const detectDuplicateMappings = (projects, selectedAccounts) => {\n  const conflicts = [];\n  const accountToProjectsMap = new Map();\n\n  // Build map of accountId -> array of projectIds\n  Object.entries(selectedAccounts).forEach(([projectId, accountId]) => {\n    if (accountId) {\n      if (!accountToProjectsMap.has(accountId)) {\n        accountToProjectsMap.set(accountId, []);\n      }\n      accountToProjectsMap.get(accountId).push(projectId);\n    }\n  });\n\n  // Find accounts mapped to multiple projects\n  accountToProjectsMap.forEach((projectIds, accountId) => {\n    if (projectIds.length > 1) {\n      const projectNames = projectIds.map(pid => {\n        const project = projects.find(p => p.id === pid);\n        return project ? project.name : pid;\n      }).filter(Boolean);\n      conflicts.push({\n        accountId,\n        projectIds,\n        projectNames,\n        type: 'duplicate',\n        message: `Account is mapped to ${projectIds.length} projects: ${projectNames.join(', ')}`\n      });\n    }\n  });\n  return conflicts;\n};\n\n/**\n * Detects if an account is already mapped to a different project\n * @param {string} accountId - The account ID to check\n * @param {string} currentProjectId - The current project ID\n * @param {Array} projects - Array of all projects\n * @returns {Object|null} - Conflict object or null\n */\nexport const detectExistingMapping = (accountId, currentProjectId, projects) => {\n  if (!accountId) return null;\n  const existingProject = projects.find(p => p.id !== currentProjectId && p.clientToolAccountUsed === accountId);\n  if (existingProject) {\n    return {\n      accountId,\n      existingProjectId: existingProject.id,\n      existingProjectName: existingProject.name,\n      currentProjectId,\n      type: 'existing_mapping',\n      message: `This account is already mapped to project: ${existingProject.name}`\n    };\n  }\n  return null;\n};\n\n/**\n * Gets all conflicts for a set of assignments\n * @param {Array} projects - Array of projects\n * @param {Object} selectedAccounts - Object mapping projectId to accountId\n * @returns {Array} - Array of all conflict objects\n */\nexport const getAllConflicts = (projects, selectedAccounts) => {\n  const conflicts = [];\n\n  // Check for duplicate mappings\n  const duplicateConflicts = detectDuplicateMappings(projects, selectedAccounts);\n  conflicts.push(...duplicateConflicts);\n\n  // Check for existing mappings\n  Object.entries(selectedAccounts).forEach(([projectId, accountId]) => {\n    if (accountId) {\n      const existingMapping = detectExistingMapping(accountId, projectId, projects);\n      if (existingMapping) {\n        conflicts.push(existingMapping);\n      }\n    }\n  });\n  return conflicts;\n};","map":{"version":3,"names":["detectDuplicateMappings","projects","selectedAccounts","conflicts","accountToProjectsMap","Map","Object","entries","forEach","projectId","accountId","has","set","get","push","projectIds","length","projectNames","map","pid","project","find","p","id","name","filter","Boolean","type","message","join","detectExistingMapping","currentProjectId","existingProject","clientToolAccountUsed","existingProjectId","existingProjectName","getAllConflicts","duplicateConflicts","existingMapping"],"sources":["/Users/mmoola/Cursor/ProjectSetup/client/src/utils/clientToolAccountConflictDetection.js"],"sourcesContent":["/**\n * Client Tool Account Conflict Detection\n * Detects duplicate mappings and conflicts\n */\n\n/**\n * Detects duplicate account mappings across projects\n * @param {Array} projects - Array of projects with account assignments\n * @param {Object} selectedAccounts - Object mapping projectId to accountId\n * @returns {Array} - Array of conflict objects { accountId, projectIds: Array<string>, type: 'duplicate' }\n */\nexport const detectDuplicateMappings = (projects, selectedAccounts) => {\n  const conflicts = [];\n  const accountToProjectsMap = new Map();\n\n  // Build map of accountId -> array of projectIds\n  Object.entries(selectedAccounts).forEach(([projectId, accountId]) => {\n    if (accountId) {\n      if (!accountToProjectsMap.has(accountId)) {\n        accountToProjectsMap.set(accountId, []);\n      }\n      accountToProjectsMap.get(accountId).push(projectId);\n    }\n  });\n\n  // Find accounts mapped to multiple projects\n  accountToProjectsMap.forEach((projectIds, accountId) => {\n    if (projectIds.length > 1) {\n      const projectNames = projectIds\n        .map(pid => {\n          const project = projects.find(p => p.id === pid);\n          return project ? project.name : pid;\n        })\n        .filter(Boolean);\n\n      conflicts.push({\n        accountId,\n        projectIds,\n        projectNames,\n        type: 'duplicate',\n        message: `Account is mapped to ${projectIds.length} projects: ${projectNames.join(', ')}`\n      });\n    }\n  });\n\n  return conflicts;\n};\n\n/**\n * Detects if an account is already mapped to a different project\n * @param {string} accountId - The account ID to check\n * @param {string} currentProjectId - The current project ID\n * @param {Array} projects - Array of all projects\n * @returns {Object|null} - Conflict object or null\n */\nexport const detectExistingMapping = (accountId, currentProjectId, projects) => {\n  if (!accountId) return null;\n\n  const existingProject = projects.find(\n    p => p.id !== currentProjectId && p.clientToolAccountUsed === accountId\n  );\n\n  if (existingProject) {\n    return {\n      accountId,\n      existingProjectId: existingProject.id,\n      existingProjectName: existingProject.name,\n      currentProjectId,\n      type: 'existing_mapping',\n      message: `This account is already mapped to project: ${existingProject.name}`\n    };\n  }\n\n  return null;\n};\n\n/**\n * Gets all conflicts for a set of assignments\n * @param {Array} projects - Array of projects\n * @param {Object} selectedAccounts - Object mapping projectId to accountId\n * @returns {Array} - Array of all conflict objects\n */\nexport const getAllConflicts = (projects, selectedAccounts) => {\n  const conflicts = [];\n\n  // Check for duplicate mappings\n  const duplicateConflicts = detectDuplicateMappings(projects, selectedAccounts);\n  conflicts.push(...duplicateConflicts);\n\n  // Check for existing mappings\n  Object.entries(selectedAccounts).forEach(([projectId, accountId]) => {\n    if (accountId) {\n      const existingMapping = detectExistingMapping(accountId, projectId, projects);\n      if (existingMapping) {\n        conflicts.push(existingMapping);\n      }\n    }\n  });\n\n  return conflicts;\n};\n\n"],"mappings":"AAAA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,MAAMA,uBAAuB,GAAGA,CAACC,QAAQ,EAAEC,gBAAgB,KAAK;EACrE,MAAMC,SAAS,GAAG,EAAE;EACpB,MAAMC,oBAAoB,GAAG,IAAIC,GAAG,CAAC,CAAC;;EAEtC;EACAC,MAAM,CAACC,OAAO,CAACL,gBAAgB,CAAC,CAACM,OAAO,CAAC,CAAC,CAACC,SAAS,EAAEC,SAAS,CAAC,KAAK;IACnE,IAAIA,SAAS,EAAE;MACb,IAAI,CAACN,oBAAoB,CAACO,GAAG,CAACD,SAAS,CAAC,EAAE;QACxCN,oBAAoB,CAACQ,GAAG,CAACF,SAAS,EAAE,EAAE,CAAC;MACzC;MACAN,oBAAoB,CAACS,GAAG,CAACH,SAAS,CAAC,CAACI,IAAI,CAACL,SAAS,CAAC;IACrD;EACF,CAAC,CAAC;;EAEF;EACAL,oBAAoB,CAACI,OAAO,CAAC,CAACO,UAAU,EAAEL,SAAS,KAAK;IACtD,IAAIK,UAAU,CAACC,MAAM,GAAG,CAAC,EAAE;MACzB,MAAMC,YAAY,GAAGF,UAAU,CAC5BG,GAAG,CAACC,GAAG,IAAI;QACV,MAAMC,OAAO,GAAGnB,QAAQ,CAACoB,IAAI,CAACC,CAAC,IAAIA,CAAC,CAACC,EAAE,KAAKJ,GAAG,CAAC;QAChD,OAAOC,OAAO,GAAGA,OAAO,CAACI,IAAI,GAAGL,GAAG;MACrC,CAAC,CAAC,CACDM,MAAM,CAACC,OAAO,CAAC;MAElBvB,SAAS,CAACW,IAAI,CAAC;QACbJ,SAAS;QACTK,UAAU;QACVE,YAAY;QACZU,IAAI,EAAE,WAAW;QACjBC,OAAO,EAAE,wBAAwBb,UAAU,CAACC,MAAM,cAAcC,YAAY,CAACY,IAAI,CAAC,IAAI,CAAC;MACzF,CAAC,CAAC;IACJ;EACF,CAAC,CAAC;EAEF,OAAO1B,SAAS;AAClB,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,MAAM2B,qBAAqB,GAAGA,CAACpB,SAAS,EAAEqB,gBAAgB,EAAE9B,QAAQ,KAAK;EAC9E,IAAI,CAACS,SAAS,EAAE,OAAO,IAAI;EAE3B,MAAMsB,eAAe,GAAG/B,QAAQ,CAACoB,IAAI,CACnCC,CAAC,IAAIA,CAAC,CAACC,EAAE,KAAKQ,gBAAgB,IAAIT,CAAC,CAACW,qBAAqB,KAAKvB,SAChE,CAAC;EAED,IAAIsB,eAAe,EAAE;IACnB,OAAO;MACLtB,SAAS;MACTwB,iBAAiB,EAAEF,eAAe,CAACT,EAAE;MACrCY,mBAAmB,EAAEH,eAAe,CAACR,IAAI;MACzCO,gBAAgB;MAChBJ,IAAI,EAAE,kBAAkB;MACxBC,OAAO,EAAE,8CAA8CI,eAAe,CAACR,IAAI;IAC7E,CAAC;EACH;EAEA,OAAO,IAAI;AACb,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,MAAMY,eAAe,GAAGA,CAACnC,QAAQ,EAAEC,gBAAgB,KAAK;EAC7D,MAAMC,SAAS,GAAG,EAAE;;EAEpB;EACA,MAAMkC,kBAAkB,GAAGrC,uBAAuB,CAACC,QAAQ,EAAEC,gBAAgB,CAAC;EAC9EC,SAAS,CAACW,IAAI,CAAC,GAAGuB,kBAAkB,CAAC;;EAErC;EACA/B,MAAM,CAACC,OAAO,CAACL,gBAAgB,CAAC,CAACM,OAAO,CAAC,CAAC,CAACC,SAAS,EAAEC,SAAS,CAAC,KAAK;IACnE,IAAIA,SAAS,EAAE;MACb,MAAM4B,eAAe,GAAGR,qBAAqB,CAACpB,SAAS,EAAED,SAAS,EAAER,QAAQ,CAAC;MAC7E,IAAIqC,eAAe,EAAE;QACnBnC,SAAS,CAACW,IAAI,CAACwB,eAAe,CAAC;MACjC;IACF;EACF,CAAC,CAAC;EAEF,OAAOnC,SAAS;AAClB,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}